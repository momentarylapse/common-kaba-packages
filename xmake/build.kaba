use project
use makefile
use library
use os
use thread
use time




func is_completely_built(s: SourceFile) -> bool
	if not os.Filesystem.exists(s.object())
		return false
	var ts = os.Filesystem.mtime(s.filename)
	var to = os.Filesystem.mtime(s.object())
	if to.time < ts.time
		return false
	for d in s.dep
		var td = os.Filesystem.mtime(d)
		if to.time < td.time
			return false
	return true

func compile(s: SourceFile, cxx_flags: string) -> bool
	var command = "g++ -c {{rel(s.filename)}} -o {{rel(s.object())}} {{cxx_flags}}"
	if conf.verbose
		print(command)
	try
		var r = shell_execute(command)
	except Exception as e
		#print("ERROR:")
		#print(e)
		return false
	return true

class T extends Thread
	SourceFile s
	string cxx_flags
	func override on_run()
		#print("COMPILE  {{s.filename}}")
		compile(s, cxx_flags)
		#time.sleep(1)



 func get_profile(name: string) -> Profile
	for p in conf.profiles
		if p.name == name
			return p
	Profile p
	p.name = "local"
	for l in conf.libs_optional
		if (lib.has(l) or conf.force_all_libraries) and !conf.ignored(l)
			p.libs_optional.add(l)
	return p

func build()
	if conf.force_rebuild
		build_clear()


	var p = get_profile(conf.force_profile)
	
	var binary_file = Path("..") << conf.binary_file
			
	string cflags, lflags, defines
	collect_global_flags(p, cflags, lflags, defines)
	string x
	if conf.build_type == "debug"
		x = "-g"
	var global_flags = "{{conf.flags_global}} -O{{conf.optimization}} {{x}} -std={{conf.language}} {{defines}}"
	var cxx_flags = "{{conf.flags_compiler}} {{cflags}} {{global_flags}}"
	var cxx_flags_linking = "{{conf.flags_linker}} {{lflags}} {{global_flags}}"
	
	var needs_building = [for s in sources s if not is_completely_built(s)]
	#print("total {{len(sources)}}, build {{len(needs_building)}}")
	
	
	int num_threads = Thread.get_num_cores()
	
	if num_threads > 1

		T*[] threads
		for i in 0:num_threads
			threads.add(new T())
	
		for s,i in needs_building
			T* t = nil
			if i < num_threads
				#print("{{i}} -> direct")
				t = new T()
				threads.add(t)
			else
				#print("{{i}} -> pool")
				while not t
					for tt in threads
						if tt.is_done()
							tt.join()
							# TODO allow multiple run()s
							del tt
							tt = new T()
							t = tt
							break
			print("{{i+1|3}}/{{len(needs_building)}} {{Term.YELLOW}}{{rel(s.filename)}}{{Term.END}}")
			t.s = s
			t.cxx_flags = cxx_flags
			t.run()
		
		for t in threads
			t.join()
			del t
	
#	for t in threads
#		t.run()
#	for t in threads
#		t.join()
	##CompilerPool cp
	#cp.run(100,1)
	#time.sleep(10)
	
	else
		for s,i in needs_building
			print("{{i+1|3}}/{{len(needs_building)}} {{Term.YELLOW}}{{rel(s.filename)}}{{Term.END}}")
			if not compile(s, cxx_flags)
				return


	if len(needs_building) == 0 and os.Filesystem.exists(binary_file)
		print("  up to date")
		return
			
	print("Link  {{Term.YELLOW}}{{binary_file}}{{Term.END}}")
	var main_ob = conf.main_file.replace(".cpp", ".o")
	var obj = collect_objects().join(" ")
	var command = "g++ {{obj}} {{main_ob}} -o {{binary_file}} {{cxx_flags_linking}}"
	if conf.verbose
		print(command)
	try
		var r = shell_execute(command)
	except Exception as e
		#print("ERROR:")
		#print(e)
		return



func build_clear()
	for s in sources
		try
			os.Filesystem.delete(s.object())
			#print(s.object())
		except
			pass
	var binary_file = Path("..") << conf.binary_file
	try
		os.Filesystem.delete(binary_file)
	except
		pass
	
	