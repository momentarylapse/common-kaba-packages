use kaba

class CLIParser
	var static current: CLIParser*
	
	class Command
		var name: string[]
		var params: string[]
		var f: string[]->void
		var comment: string

		func match(arg: string[]) -> bool
			if len(arg) < len(name)
				return false
			for n,i in name
				if arg[i] != n
					return false
			return true
		
		func min_params() -> int
			int m = 0
			for p in params
				if p == "..."
					continue
				if p[0:1] == "<"
					m ++
			return m

		func sig() -> string
			return name.join(" ") + " " + params.join(" ")
	class Option
		var name: string[]
		var param: string
		var f1: string->void
		var f0: void->void
		var comment: string
		
		func sig() -> string
			string s = name.join(", ")
			if param != ""
				s += " {{param}}"
			return s
		
	var commands: Command[]
	var options: Option[]
	var _info: string
	
	func mut info(i: string)
		_info = i

	# "example", "<P1> <P2> [OPT] ...", "comment", lambda(string[] a) ...
	#  name = "" -> default
	func mut cmd(name: string, params: string, comment: string, f: string[]->void)
		Command c
		c.name = name.explode(" ")
		c.params = params.explode(" ")
		c.f = f
		c.comment = comment
		commands.add(c)

	# ["--example", "-e"], "<P1> <P2> [OPT] ...", "comment", lambda(string a) ...
	func mut optx(name: string[], param: string, comment: string, f1: string->void, f0: void->void)
		Option c
		c.name = name
		c.param = param
		c.comment = comment
		c.f1 = f1
		c.f0 = f0
		options.add(c)
		
	# ["--example", "-e"], "comment", lambda() ...
	func mut opta(name: string[], param: string, comment: string, f: string->void)
		optx(name, param, comment, f, nil)

	func mut opt(name: string[], comment: string, f: void->void)
		optx(name, "", comment, nil, f)

	func run(arg: string[])
		current = &self
		try
			var arg2 = parse_options(arg)
			if parse_commands(arg2)
				return
			if len(arg2) > 0
				print("ERROR: unhandled command")
			show_help()
		except Exception as e
			print("ERROR: {{e}}")
	
	func parse_options(arg: string[]) -> string[]
		string[] arg2
		for a,i in arg
			if a[:1] == "-"
				i += do_option(a, arg[i+1:])
			else
				arg2.add(a)
		return arg2

	func do_option(name: string, arg_rest: string[]) -> int
		for o in options
			if name in o.name
				#print("option {{o.name}}")
				if o.param == ""
					o.f0()
					return 0
				else
					if len(arg_rest) == 0
						raise(new Exception("missing parameter: {{o.sig()}}"))
					o.f1(arg_rest[0])
					return 1
		raise(new Exception("unknown option {{name}}"))
	
	func parse_commands(arg: string[]) -> bool
		for c in commands
			if c.match(arg)
				if len(arg) - len(c.name) < c.min_params()
					raise(new Exception("missing parameters: {{c.sig()}}"))
				#print("command {{c.name}}")
				var aa = arg[len(c.name):]
				c.f(aa)
				return true
		return false

	func show_help()
		if _info != ""
			print(_info)
			print("")
		print("commands:")
		for c in commands
			var s = c.sig()
			print("  {{s|-30}} # {{c.comment}}")
		
		if len(options) > 0
			print("")
			print("options:")
			for o in options
				var s = o.sig()
				print("  {{s|-30}} # {{o.comment}}")
