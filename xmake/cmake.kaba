use os
use project.*
use library.*
use vcpkg.*


func var_name(l: string) -> string
	return l.upper().replace("-", "").replace(".", "")

func cmake_link_mandatory_lib(l: string) -> string
	let ll = lib.get(l)
	let varx = var_name(l)
	#deps.add("{{varx}}_LIBRARIES")
	if len(ll.pkg) > 0
		return "

# lib: {{l}} mandatory
pkg_check_modules({{varx}} REQUIRED {{ll.pkg[0]}})
list(APPEND INCLUDE_DIRECTORIES ${"+varx+"_INCLUDE_DIRS})
list(APPEND LINK_DIRECTORIES ${"+varx+"_LIBRARY_DIRS})
list(APPEND DEPS ${"+varx+"_LIBRARIES})
list(APPEND COMPILE_OPTIONS ${"+varx+"_CFLAGS_OTHER})
list(APPEND COMPILE_DEFINITIONS {{ll.define()}}=1)"
	else
		print("ERROR: no pkg for mandatory lib {{l}}")
		return ""


func cmake_link_mandatory_group(g: LibGroup) -> string
	let lls = [for l in g.libs  lib.get(l)]
	let varxs = g.libs |> var_name
	#deps.add("{{varx}}_LIBRARIES")
	let cvar = varxs.join("_OR_")
	let label = g.libs.join(" or ")
	var s = "

# lib: {{label}} (mandatory)
set({{cvar}} \"{{g.libs[0]}}\" CACHE STRING \"Use {{label}}?\")"

	for i=>v in varxs
		if len(lls[i].pkg) > 0
			s += "
pkg_check_modules({{v}} {{lls[i].pkg[0]}})
if({{v}}_FOUND)
	list(APPEND {{cvar}}_FOUND \"{{g.libs[i]}}\")
endif()"
	s += "
if({{cvar}}_FOUND)
	if(NOT ${GTK3_OR_GTK4} IN_LIST {{cvar}}_FOUND)
		list(GET {{cvar}}_FOUND 0 X)
		set({{cvar}} ${X} CACHE STRING \"choose\" FORCE)
		message(WARNING \"Choice for {{cvar}} invalid, using ${"+cvar+"} instead\")
	endif()
else()
	message(SEND_ERROR \"Neither {{label}} found\") #  or/nor..
	set({{cvar}} \"\")
endif()"
	
	for i=>v in varxs
		s += "
if({{cvar}} STREQUAL \"{{g.libs[i]}}\")"
		if len(lls[i].pkg) > 0
			s += "
	list(APPEND INCLUDE_DIRECTORIES ${"+v+"_INCLUDE_DIRS})
	list(APPEND LINK_DIRECTORIES ${"+v+"_LIBRARY_DIRS})
	list(APPEND DEPS ${"+v+"_LIBRARIES})
	list(APPEND COMPILE_OPTIONS ${"+v+"_CFLAGS_OTHER})
	list(APPEND COMPILE_DEFINITIONS{{lls[i].define()}}=1)"
		else
			print("ERROR: no pkg for {{lls[i]}}")
		s += "
endif()"
	return s


func cmake_link_optional_lib(l: string) -> string
	let ll = lib.get(l)
	#deps.add("{{varx}}_LIBRARIES")
	
	let var_enabled = "LIB_{{var_name(l)}}_ENABLED"
	
	#for _code in ll.cmake_code
	if len(ll.cmake_code) > 0
		let code = ll.cmake_code.replace(":define:", ll.define())
		return "

# lib: {{l}} (optional)
{{code}}"

	if len(ll.pkg) > 0
		# => pkg
		let varx = ll.pkg |> var_name
		var r = "

# lib: {{l}} (optional)
set({{var_enabled}} true CACHE BOOL \"Use {{l}} library?\")"
		for i=>v in varx
			r += "
pkg_check_modules({{v}} {{ll.pkg[i]}})"
		r += "
if(" + ([for v in varx "{{v}}_FOUND"].join(" AND ")) + ")"
		for i=>v in varx
			r += "
	list(APPEND INCLUDE_DIRECTORIES ${"+v+"_INCLUDE_DIRS})
	list(APPEND LINK_DIRECTORIES ${"+v+"_LIBRARY_DIRS})
	list(APPEND DEPS ${"+v+"_LIBRARIES})
	list(APPEND COMPILE_OPTIONS ${"+v+"_CFLAGS_OTHER})"
		r += "
else()
	set({{var_enabled}} false CACHE BOOL \"{{l}} library not found\" FORCE)
endif()
if(${"+var_enabled+"})
	list(APPEND COMPILE_DEFINITIONS {{ll.define()}}=1)
else()
	list(APPEND COMPILE_DEFINITIONS {{ll.define()}}=0)
endif()"
		return r

	else if len(ll.cmake) > 0
		# => cmake
		let cn = ll.cmake[0]
		return "

# lib: {{l}} (optional)
set({{var_enabled}} true CACHE BOOL \"Use {{l}} library?\")
find_package({{cn}})
if({{cn}}_FOUND)
	list(APPEND INCLUDE_DIRECTORIES ${"+cn+"_INCLUDE_DIRS})
	list(APPEND LINK_DIRECTORIES ${"+cn+"_LIBRARY_DIRS})
	list(APPEND COMPILE_DEFINITIONS ${"+cn+"_DEFINITIONS})
	list(APPEND DEPS ${"+cn+"_LIBRARIES})
else()
	set({{var_enabled}} false CACHE BOOL \"{{l}} library not found\" FORCE)
endif()
if(${"+var_enabled+"})
	list(APPEND COMPILE_DEFINITIONS {{ll.define()}}=1)
else()
	list(APPEND COMPILE_DEFINITIONS {{ll.define()}}=0)
#endif()"

	else if l == "dl"
		return "

# lib: dl...
if(WIN32)
	list(APPEND COMPILE_DEFINITIONS {{ll.define()}}=0)
else()
	list(APPEND DEPS ${CMAKE_DL_LIBS})
	list(APPEND COMPILE_DEFINITIONS {{ll.define()}}=1)
endif()"


	print("WARNING: lib {{l}} not in cmake")
	return "

list(APPEND COMPILE_DEFINITIONS {{ll.define()}}=0)"


func create_cmake(with_vs2022: bool)
	
	print("-- cmake --")
	 
	var r = create_cmake_base()
	
	r += create_cmake_libs()
	
	r += create_cmake_install_base()

	if conf.desktop_file != ""
		r += create_cmake_install_desktop()

#	if len(conf.icons) > 0
#		r += create_cmake_install_icons()

	if len(conf.mime_files) > 0
		r += create_cmake_install_mime()
		
	os.fs.write_text(conf.root | "CMakeLists.txt", r)
	
	
	if not with_vs2022
		return
	
	os.fs.write_text(conf.root | "CMakePresets.json", "ï»¿{
	\"version\": 3,
	\"configurePresets\": [
		{
			\"name\": \"windows-base\",
			\"hidden\": true,
			\"generator\": \"Ninja\",
			\"binaryDir\": \"${sourceDir}/out/build/${presetName}\",
			\"installDir\": \"${sourceDir}/out/install/${presetName}\",
			\"toolchainFile\": \"$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake\",
			\"condition\": {
				\"type\": \"equals\",
				\"lhs\": \"${hostSystemName}\",
				\"rhs\": \"Windows\"
			}
		},
		{
			\"name\": \"x64-debug\",
			\"displayName\": \"x64 Debug\",
			\"inherits\": \"windows-base\",
			\"architecture\": {
				\"value\": \"x64\",
				\"strategy\": \"external\"
			},
			\"cacheVariables\": {
				\"CMAKE_BUILD_TYPE\": \"Debug\"
			}
		},
		{
			\"name\": \"x64-release\",
			\"displayName\": \"x64 Release\",
			\"inherits\": \"x64-debug\",
			\"cacheVariables\": {
				\"CMAKE_BUILD_TYPE\": \"Release\"
			}
		}
	]
}
".replace("\t", "    "))

	os.fs.create_directory(conf.root | ".vs")
	os.fs.write_text(conf.root | ".vs" | "launch.vs.json", "{
  \"version\": \"0.2.1\",
  \"defaults\": {},
  \"configurations\": [
    {
      \"type\": \"default\",
      \"project\": \"CMakeLists.txt\",
      \"projectTarget\": \"{{conf.targets[0].binary_file}}.exe\",
      \"name\": \"{{conf.targets[0].binary_file}}.exe\",
      \"currentDir\": \"${workspaceRoot}\"
    }
  ]
}
")

	create_vcpkg()



#find_program(XDG-MIME_EXECUTABLE xdg-mime)
#find_program(XDG-DESKTOP-MENU_EXECUTABLE xdg-desktop-menu)
#execute_process(COMMAND ${XDG-MIME_EXECUTABLE} install --novendor basket.xml)
#execute_process(COMMAND ${XDG-DESKTOP-MENU_EXECUTABLE} install --novendor basket.desktop)
#execute_process(COMMAND ${XDG-MIME_EXECUTABLE} default basket.desktop "application/x-basket-item")


func create_cmake_base() -> string
	let debug = conf.build_type == "debug"
	
	var r = "# created by xmake

cmake_minimum_required(VERSION 3.21)
project({{conf.name}})
set(CMAKE_CXX_STANDARD {{conf.language[3:]}})
set(CMAKE_CXX_STANDARD_REQUIRED True)"
	if debug
		r += "
set(CMAKE_BUILD_TYPE Debug)"
	
	let common_sources = conf.find_common_sources()
	let files = [for s in common_sources  str(rel(s))].join("\n\t")
	r += "
set(SOURCE_COMMON
	{{files}}
)"

	if len(conf.include_directories) > 0
		let dirs = conf.include_directories.join(" ")
		r += "
list(APPEND INCLUDE_DIRECTORIES {{dirs}})"
	return r



func create_cmake_libs() -> string
	var r = "

find_package(PkgConfig REQUIRED)
"

	for g in conf.lib_groups
		if g.optional
			for l in g.libs
				r += cmake_link_optional_lib(l)
		else
			if len(g.libs) > 1
				r += cmake_link_mandatory_group(g)
			else
				r += cmake_link_mandatory_lib(g.libs[0])

	
	r += "

set(THREADS_PREFER_PTHREAD_FLAG ON)
find_package(Threads REQUIRED)
list(APPEND DEPS Threads::Threads)"


	for t in conf.targets
		let xsources = conf.find_exclusive_sources(t)
		let xfiles = [for s in xsources  str(rel(s))].join("\n\t")
		r += "

# target {{t.name}}
add_executable({{t.binary_file}}
	${SOURCE_COMMON}
	{{xfiles}})
target_include_directories({{t.binary_file}} PRIVATE ${INCLUDE_DIRECTORIES})
target_link_directories({{t.binary_file}} PUBLIC ${LINK_DIRECTORIES})
target_compile_options({{t.binary_file}} PUBLIC ${COMPILE_OPTIONS})
target_compile_definitions({{t.binary_file}} PUBLIC ${COMPILE_DEFINITIONS})
target_link_libraries({{t.binary_file}} PRIVATE ${DEPS})"
		if not t.default
			r += "
set_target_properties({{t.binary_file}} PROPERTIES EXCLUDE_FROM_ALL TRUE)"
	return r


func create_cmake_install_base() -> string
	# TODO multi-target
	var r = "

target_compile_definitions({{conf.targets[0].binary_file}} PUBLIC INSTALL_PREFIX=\"${CMAKE_INSTALL_PREFIX}\")

install(TARGETS {{conf.targets[0].binary_file}} DESTINATION bin)"
	let list = conf.needs_installing()
	for e in list
		if os.fs.is_directory(conf.root | e)
			r += "
install(DIRECTORY \"{{e}}\" DESTINATION share/{{conf.name}})"
		else
			r += "
install(FILES \"{{e}}\" DESTINATION share/{{conf.name}})"
	return r


func create_cmake_install_desktop() -> string
	return "

# install .desktop file
set(INSTALL_PREFIX \"${CMAKE_INSTALL_PREFIX}\")
configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/{{conf.desktop_file}}\" /tmp/{{conf.desktop_file.basename()}} NO_SOURCE_PERMISSIONS)
install(FILES /tmp/{{conf.desktop_file.basename()}} DESTINATION share/applications)"


func create_cmake_install_icons() -> string
	var r = "

# install icons"
	for i in conf.icons
		let x = i.explode(":")
		if len(x) >= 3
			r += "
install(FILES {{x[0]}} DESTINATION share/icons/hicolor/{{x[1]}}x{{x[1]}}/apps RENAME {{x[2]}}.png)"
	return r


func create_cmake_install_mime() -> string
	var r = "

# install mime
find_program(XDG_MIME_EXECUTABLE xdg-mime)
if(NOT XDG_MIME_EXECUTABLE STREQUAL \"XDG_MIME_EXECUTABLE_NOTFOUND\")"
	for m in conf.mime_files
		r += "
	install(CODE \"message(STATUS \\\"installing mime file\\\")\")
	install(CODE \"execute_process(COMMAND ${XDG_MIME_EXECUTABLE} install --novendor ${CMAKE_CURRENT_SOURCE_DIR}/{{m}})\")"
	r += "
endif()
"
	return r
