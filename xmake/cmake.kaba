use os
use project.*
use library.*
use vcpkg


func var_name(l: string) -> string
	return l.upper().replace("-", "").replace(".", "")


func lib_discover(ll: Library, indent: string, is_required: bool) -> string
	var flag = ""
	if is_required
		flag = " REQUIRED"
	var s = ""
	if len(ll.cmake_packages) > 0
		for i=>p in ll.cmake_packages
			s += "
{{indent}}find_package({{p}}{{flag}})"
	else if len(ll.pkg) > 0
		for i=>p in ll.pkg
			let varx = var_name(p)
			s += "
{{indent}}pkg_check_modules({{varx}}{{flag}} {{p}})"
	return s[1:]

	raise(new Exception("no cmake/pkg data for mandatory lib {{ll.name}}"))


func lib_guard(ll: Library) -> string
	if ll.name == "gl"
		return "OPENGL_FOUND AND NOT APPLE"
	if len(ll.cmake_packages) > 0
		for v in ll.cmake_variable
			return v
		return var_name(ll.name) + "_FOUND"
	else if len(ll.pkg) > 0
		let varx = ll.pkg |> var_name
		return ([for v in varx "{{v}}_FOUND"].join(" AND "))
	return ""


func lib_add_data(ll: Library, indent: string) -> string
	var s = ""
	if len(ll.cmake_packages) > 0
		s = "
{{indent}}list(APPEND DEPS {{ll.cmake_targets.join(" " )}})
{{indent}}list(APPEND COMPILE_DEFINITIONS {{ll.define()}}=1)"
	else if len(ll.pkg) > 0
		for p in ll.pkg
			let varx = var_name(p)
			s += "
{{indent}}list(APPEND INCLUDE_DIRECTORIES ${"+varx+"_INCLUDE_DIRS})
{{indent}}list(APPEND LINK_DIRECTORIES ${"+varx+"_LIBRARY_DIRS})
{{indent}}list(APPEND DEPS ${"+varx+"_LIBRARIES})
{{indent}}list(APPEND COMPILE_OPTIONS ${"+varx+"_CFLAGS_OTHER})"
		s += "
{{indent}}list(APPEND COMPILE_DEFINITIONS {{ll.define()}}=1)"
	else
		raise(new Exception("no cmake/pkg data for mandatory lib {{ll.name}}"))
	return s[1:]


func link_mandatory_lib(l: string) -> string
	let ll = lib.get(l)
	return "


# lib: {{l}} (mandatory)
{{lib_discover(ll, "", true)}}
{{lib_add_data(ll, "")}}"


# a|b|c
func link_mandatory_group(g: LibGroup) -> string
	let lls = [for l in g.libs  lib.get(l)]
	let varxs = g.libs |> var_name
	#deps.add("{{varx}}_LIBRARIES")
	let cvar = varxs.join("_OR_")
	let label = g.libs.join(" or ")
	var s = "


# lib: {{label}} (mandatory)
set({{cvar}} \"{{g.libs[0]}}\" CACHE STRING \"Use {{label}}?\")"

	for i=>v in varxs
		s += "
{{lib_discover(lls[i], "", false)}}
if({{v}}_FOUND)
	list(APPEND {{cvar}}_FOUND \"{{g.libs[i]}}\")
endif()"
	s += "
if({{cvar}}_FOUND)
	if(NOT ${"+cvar+"} IN_LIST {{cvar}}_FOUND)
		list(GET {{cvar}}_FOUND 0 X)
		set({{cvar}} ${X} CACHE STRING \"choose\" FORCE)
		message(WARNING \"Choice for {{cvar}} invalid, using ${"+cvar+"} instead\")
	endif()
else()
	message(SEND_ERROR \"Neither {{label}} found\") #  or/nor..
	set({{cvar}} \"\")
endif()"
	
	for i=>v in varxs
		s += "
if({{cvar}} STREQUAL \"{{g.libs[i]}}\")
{{lib_add_data(lls[i], "	")}}
endif()"
	return s



func link_optional_lib(l: string) -> string
	let ll = lib.get(l)
	#deps.add("{{varx}}_LIBRARIES")
	
	let var_enabled = "LIB_{{var_name(l)}}_ENABLED"
	
	#for _code in ll.cmake_code
	if len(ll.cmake_code) > 0
		let code = ll.cmake_code.replace(":define:", ll.define())
		return "


# lib: {{l}} (optional)
{{code}}"


	if l == "dl"
		return "


# lib: dl...
if(WIN32)
	list(APPEND COMPILE_DEFINITIONS {{ll.define()}}=0)
else()
	list(APPEND DEPS ${CMAKE_DL_LIBS})
	list(APPEND COMPILE_DEFINITIONS {{ll.define()}}=1)
endif()"




	var r = "


# lib: {{l}} (optional)
set({{var_enabled}} true CACHE BOOL \"Use {{l}} library?\")
{{lib_discover(ll, "", false)}}
if({{lib_guard(ll)}})
else()
	set({{var_enabled}} false CACHE BOOL \"{{l}} library not found\" FORCE)
endif()
if(${"+var_enabled+"})
{{lib_add_data(ll, "	")}}
else()
	list(APPEND COMPILE_DEFINITIONS {{ll.define()}}=0)
endif()"
	return r


	print("WARNING: lib {{l}} not in cmake")
	return "

list(APPEND COMPILE_DEFINITIONS {{ll.define()}}=0)"




func create_base() -> string
	let debug = conf.build_type == "debug"
	
	var r = "# created by xmake

cmake_minimum_required(VERSION 3.21)
project({{conf.name}})
set(CMAKE_CXX_STANDARD {{conf.language[3:]}})
set(CMAKE_CXX_STANDARD_REQUIRED True)"
	if debug
		r += "
set(CMAKE_BUILD_TYPE Debug)"
	
#	let common_sources = conf.find_common_sources()
#	let files = [for s in common_sources  str(rel(s))].join("\n\t")
#	r += "
#set(SOURCE_COMMON
#	{{files}}
#)"

#	if len(conf.include_directories) > 0
#		let dirs = conf.include_directories.join(" ")
#		r += "
#list(APPEND INCLUDE_DIRECTORIES {{dirs}})"
	return r



func create_libs() -> string
	var r = "

#=======================================================================================
#    libs
#=======================================================================================

find_package(PkgConfig REQUIRED)
"

	let lib_groups = conf.dependencies()
	for g in lib_groups
		if g.optional
			for l in g.libs
				r += link_optional_lib(l)
		else
			if len(g.libs) > 1
				r += link_mandatory_group(g)
			else
				r += link_mandatory_lib(g.libs[0])

	
	r += "

set(THREADS_PREFER_PTHREAD_FLAG ON)
find_package(Threads REQUIRED)
list(APPEND DEPS Threads::Threads)"

	if "gitversion" in conf.features
		r += "

# git version
include(.cmake/CheckGit.cmake)
CheckGitSetup()
list(APPEND DEPS git-version)"

	return r


func create_target(t: BuildTarget) -> string
	let xsources = conf.find_sources(t)
	let xfiles = [for s in xsources  str(rel(s))].join("\n\t")
	
	var deps = "${DEPS}"
	for d in t.dependencies
		if conf.find_target(d.libs[0])
			deps += " {{d.libs[0]}}"
	
	var r = "

#=======================================================================================
#    target {{t.name}}
#=======================================================================================
"
	if t.is_library
		r += "
add_library({{t.binary_file}}"
	else
		r += "
add_executable({{t.binary_file}}"
	r += "
	{{xfiles}})
target_include_directories({{t.binary_file}} PUBLIC ${INCLUDE_DIRECTORIES})
target_link_directories({{t.binary_file}} PUBLIC ${LINK_DIRECTORIES})
target_compile_options({{t.binary_file}} PUBLIC ${COMPILE_OPTIONS})
target_compile_definitions({{t.binary_file}} PUBLIC ${COMPILE_DEFINITIONS} INSTALL_PREFIX=\"${CMAKE_INSTALL_PREFIX}\")
target_link_libraries({{t.binary_file}} PUBLIC {{deps}})"
	for i in t.include_directories
		r += "
target_include_directories({{t.binary_file}} PUBLIC {{i}})"
	
	if not t.default
		r += "
set_target_properties({{t.binary_file}} PROPERTIES EXCLUDE_FROM_ALL TRUE)"
	return r




func create_install_base() -> string
	var r = "

#=======================================================================================
#    install
#=======================================================================================
"

	for t in conf.targets
		if t.default and not t.is_library
			r += "
install(TARGETS {{t.binary_file}} DESTINATION bin)"
	let list = conf.needs_installing()
	for e in list
		if os.fs.is_directory(conf.root | e)
			r += "
install(DIRECTORY \"{{e}}\" DESTINATION share/{{conf.name}})"
		else
			r += "
install(FILES \"{{e}}\" DESTINATION share/{{conf.name}})"
	return r


func create_install_desktop() -> string
	return "

# install .desktop file
set(INSTALL_PREFIX \"${CMAKE_INSTALL_PREFIX}\")
configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/{{conf.desktop_file}}\" /tmp/{{conf.desktop_file.basename()}} NO_SOURCE_PERMISSIONS)
install(FILES /tmp/{{conf.desktop_file.basename()}} DESTINATION share/applications)"


func create_install_icons() -> string
	var r = "

# install icons"
	for i in conf.icons
		let x = i.explode(":")
		if len(x) >= 3
			r += "
install(FILES {{x[0]}} DESTINATION share/icons/hicolor/{{x[1]}}x{{x[1]}}/apps RENAME {{x[2]}}.png)"
	return r


func create_install_mime() -> string
	var r = "

# install mime
find_program(XDG_MIME_EXECUTABLE xdg-mime)
if(NOT XDG_MIME_EXECUTABLE STREQUAL \"XDG_MIME_EXECUTABLE_NOTFOUND\")"
	for m in conf.mime_files
		r += "
	install(CODE \"message(STATUS \\\"installing mime file\\\")\")
	install(CODE \"execute_process(COMMAND ${XDG_MIME_EXECUTABLE} install --novendor ${CMAKE_CURRENT_SOURCE_DIR}/{{m}})\")"
	r += "
endif()
"
	return r


func create_git_version()
	os.fs.create_directory(conf.root | ".cmake")
	
	os.fs.write_text(conf.root | ".cmake/git-version.h", "#ifndef GIT_VERSION_H
#define GIT_VERSION_H

extern const char* GitHash;

#endif // GIT_VERSION_H
")
	os.fs.write_text(conf.root | ".cmake/git-version.cpp.in", "#include \"git-version.h\"

const char* GitHash = \"@GIT_HASH@\";")


	os.fs.write_text(conf.root | ".cmake/CheckGit.cmake", "# stolen from https://jonathanhamberg.com/post/cmake-embedding-git-hash/


set(CURRENT_LIST_DIR ${CMAKE_CURRENT_LIST_DIR})
if (NOT DEFINED pre_configure_dir)
    set(pre_configure_dir ${CMAKE_CURRENT_LIST_DIR})
endif ()

if (NOT DEFINED post_configure_dir)
    set(post_configure_dir ${CMAKE_BINARY_DIR}/generated)
endif ()

set(pre_configure_file ${pre_configure_dir}/git-version.cpp.in)
set(post_configure_file ${post_configure_dir}/git-version.cpp)

function(CheckGitWrite git_hash)
    file(WRITE ${CMAKE_BINARY_DIR}/git-state.txt ${git_hash})
endfunction()

function(CheckGitRead git_hash)
    if (EXISTS ${CMAKE_BINARY_DIR}/git-state.txt)
        file(STRINGS ${CMAKE_BINARY_DIR}/git-state.txt CONTENT)
        LIST(GET CONTENT 0 var)

        set(${git_hash} ${var} PARENT_SCOPE)
    endif ()
endfunction()

function(CheckGitVersion)
    # Get the latest abbreviated commit hash of the working branch
    execute_process(
        COMMAND git describe --tags
        WORKING_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}
        OUTPUT_VARIABLE GIT_HASH
        OUTPUT_STRIP_TRAILING_WHITESPACE
        )

    CheckGitRead(GIT_HASH_CACHE)
    if (NOT EXISTS ${post_configure_dir})
        file(MAKE_DIRECTORY ${post_configure_dir})
    endif ()

    if (NOT EXISTS ${post_configure_dir}/git-version.h)
        file(COPY ${pre_configure_dir}/git-version.h DESTINATION ${post_configure_dir})
    endif()

    if (NOT DEFINED GIT_HASH_CACHE)
        set(GIT_HASH_CACHE \"INVALID\")
    endif ()

    # Only update the git-version.cpp if the hash has changed. This will
    # prevent us from rebuilding the project more than we need to.
    if (NOT ${GIT_HASH} STREQUAL ${GIT_HASH_CACHE} OR NOT EXISTS ${post_configure_file})
        # Set che GIT_HASH_CACHE variable the next build won't have
        # to regenerate the source file.
        CheckGitWrite(${GIT_HASH})

        configure_file(${pre_configure_file} ${post_configure_file} @ONLY)
    endif ()

endfunction()

function(CheckGitSetup)

    add_custom_target(AlwaysCheckGit COMMAND ${CMAKE_COMMAND}
        -DRUN_CHECK_GIT_VERSION=1
        -Dpre_configure_dir=${pre_configure_dir}
        -Dpost_configure_file=${post_configure_dir}
        -DGIT_HASH_CACHE=${GIT_HASH_CACHE}
        -P ${CURRENT_LIST_DIR}/CheckGit.cmake
        BYPRODUCTS ${post_configure_file}
        )

    add_library(git-version ${CMAKE_BINARY_DIR}/generated/git-version.cpp)
    target_include_directories(git-version PUBLIC ${CMAKE_BINARY_DIR}/generated)
    add_dependencies(git-version AlwaysCheckGit)

    CheckGitVersion()
endfunction()

# This is used to run this function from an external cmake process.
if (RUN_CHECK_GIT_VERSION)
    CheckGitVersion()
endif ()
")




func create(with_vs2022: bool)
	
	print("-- cmake --")
	 
	var r = create_base()
	
	r += create_libs()
	
	

	for t in conf.targets
		r += create_target(t)
	
	r += create_install_base()

	if conf.desktop_file != ""
		r += create_install_desktop()

#	if len(conf.icons) > 0
#		r += create_install_icons()

	if len(conf.mime_files) > 0
		r += create_install_mime()
		
	os.fs.write_text(conf.root | "CMakeLists.txt", r)
	
	if "gitversion" in conf.features
		create_git_version()
	
	
	if not with_vs2022
		return
	
	os.fs.write_text(conf.root | "CMakePresets.json", "﻿{
	\"version\": 3,
	\"configurePresets\": [
		{
			\"name\": \"windows-base\",
			\"hidden\": true,
			\"generator\": \"Ninja\",
			\"binaryDir\": \"${sourceDir}/out/build/${presetName}\",
			\"installDir\": \"${sourceDir}/out/install/${presetName}\",
			\"toolchainFile\": \"$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake\",
			\"condition\": {
				\"type\": \"equals\",
				\"lhs\": \"${hostSystemName}\",
				\"rhs\": \"Windows\"
			}
		},
		{
			\"name\": \"x64-debug\",
			\"displayName\": \"x64 Debug\",
			\"inherits\": \"windows-base\",
			\"architecture\": {
				\"value\": \"x64\",
				\"strategy\": \"external\"
			},
			\"cacheVariables\": {
				\"CMAKE_BUILD_TYPE\": \"Debug\"
			}
		},
		{
			\"name\": \"x64-release\",
			\"displayName\": \"x64 Release\",
			\"inherits\": \"x64-debug\",
			\"cacheVariables\": {
				\"CMAKE_BUILD_TYPE\": \"Release\"
			}
		}
	]
}
".replace("\t", "    "))

	let t = conf.main_target()

	os.fs.create_directory(conf.root | ".vs")
	os.fs.write_text(conf.root | ".vs" | "launch.vs.json", "{
  \"version\": \"0.2.1\",
  \"defaults\": {},
  \"configurations\": [
    {
      \"type\": \"default\",
      \"project\": \"CMakeLists.txt\",
      \"projectTarget\": \"{{t.binary_file}}.exe\",
      \"name\": \"{{t.binary_file}}.exe\",
      \"currentDir\": \"${workspaceRoot}\"
    }
  ]
}
")

	vcpkg.create()



#find_program(XDG-MIME_EXECUTABLE xdg-mime)
#find_program(XDG-DESKTOP-MENU_EXECUTABLE xdg-desktop-menu)
#execute_process(COMMAND ${XDG-MIME_EXECUTABLE} install --novendor basket.xml)
#execute_process(COMMAND ${XDG-DESKTOP-MENU_EXECUTABLE} install --novendor basket.desktop)
#execute_process(COMMAND ${XDG-MIME_EXECUTABLE} default basket.desktop "application/x-basket-item")
