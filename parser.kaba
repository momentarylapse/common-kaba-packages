use "common.kaba"

void RaiseParserError(string s)
	ParserError = true
	ParserMsg = s
	print("Parser Fehler: " + s)

int CharType(char c)
	if (c >= 'a') and (c <= 'z')
		return CHAR_LETTER
	if (c >= 'A') and (c <= 'Z')
		return CHAR_LETTER
	if (c >= '0') and (c <= '9')
		return CHAR_NUMBER
	return CHAR_SIGN

string GetExpr(string s, int p)
	string r
	char c = s[p]
	int ct = CharType(c)
	r.add(c)
	if ct != CHAR_SIGN
		for i in p+1:s.num
			if CharType(s[i]) == ct
				r.add(s[i])
			else
				break
	return r

string[] expr
void Analyze(string s)
	ParserError = false
	expr.clear()
	s.replace(" ", "")
	s.replace("\t", "")
	s.replace("\n", "")
	//print s
	for i in 0:s.num
		string e = GetExpr(s, i)
		expr.add(e)
		i += e.num -1

bool IsFunction(string s)
	if (s == "sin") or (s == "cos") or (s == "exp") or (s == "ln") or (s == "sqrt") or (s == "sinh") or (s == "cosh")
		return true
	if (s == "expand") or (s == "simplify") or (s == "diff")
		return true
	return false

int OperatorRank(string s)
	if (s == "+") or (s == "-")
		return 1
	if (s == "*") or (s == "/")
		return 2
	if (s == "^")
		return 3
	return -1

int GetBrackets(string[] e, int i0)
	int np = 1
	for j in i0+1:e.num
		if e[j] == "("
			np ++
		if e[j] == ")"
			np --
			if np == 0
				return j
	RaiseParserError("Klammer ) vermisst")
	return -1
	

Term *ParsePart(string[] e)
	//print e

	if e.num == 0
		RaiseParserError("leerer Ausdruck")
		return nil
	
	Term*[] eid
	
	for i in 0:e.num
		//print i
		if e[i] == "("
			int i_last = GetBrackets(e, i)
			if ParserError
				return nil
			if i_last <= i + 2
				RaiseParserError("leere Klammer")
				return nil
			eid.add(ParsePart(e.subarray(i + 1, i_last - i - 1)))
			i = i_last
		else if e[i] == ")"
			RaiseParserError("überflüssige Klammer )")
			return nil
		else if CharType(e[i][0]) == CHAR_NUMBER
			eid.add(AddNumber(e[i]))
		else if CharType(e[i][0]) == CHAR_LETTER
			if IsFunction(e[i])
				if e[i+1] != "("
					RaiseParserError("Klammer ( nach Funktion vermisst")
					return nil
				int i_last = GetBrackets(e, i + 1)
				if ParserError
					return nil
				if i_last <= i + 2
					RaiseParserError("fehlender Funktionsparameter")
					return nil
				string[] ee
				for j in i+2:i_last
					ee.add(e[j])
				Term *sub = ParsePart(ee)//e.subarray(i + 1, i_last))
				eid.add(AddFunction(e[i], sub))
				i = i_last
			else
				eid.add(AddVariable(e[i]))
		else if CharType(e[i][0]) == CHAR_SIGN
			if OperatorRank(e[i]) < 0
				RaiseParserError("unbekannter Operator '" + e[i] + "'")
				return nil
			eid.add(AddOperator(e[i], nil, nil))
		if ParserError
			return nil
	
	if (eid.num % 2) != 1
		RaiseParserError("Operator/Operand kaputt")
		return nil
	
	while eid.num > 2
		int i_sig, sig = -1
		for i in 0:eid.num
			if (i % 2) == 1
				int os = OperatorRank(eid[i].name)
				if os > sig
					sig = os
					i_sig = i
		if eid[i_sig].type != TYPE_OPERATOR
			RaiseParserError("Operator vermisst")
			return nil
		eid[i_sig].params[0] = eid[i_sig - 1]
		eid[i_sig].params[1] = eid[i_sig + 1]
		eid[i_sig - 1] = eid[i_sig]
		eid.remove(i_sig)
		eid.remove(i_sig)
	//print eid
	
	
	return eid[0]

Term *Parse(string s)
	Analyze(s)
	return ParsePart(expr)

