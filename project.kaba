use os


class Profile
	string name
	string[] libs_optional

# project
class Config
	Path root
	bool verbose
	bool dry_run
	
	string name
	string binary_file
	string main_file
	string[] libs
	string[] libs_optional
	string[] ignore_libs
	Profile[] profiles
	string language
	string optimization
	string build_type
	string flags_global
	string flags_compiler
	string flags_linker
	string[] icons
	string desktop_file
	string[] mime_files
	string[] installs
	
	void __init__()
		language = "c++17"
		optimization = "2"
		build_type = "debug"
		verbose = false
		dry_run = false
	
	bool ignored(string l)
		for ig in ignore_libs
			if l == ig
				return true
		return false
	
	void load()
		File* f = Filesystem.open_text(conf.root << "xmake.conf")
		string t
		while !f.eof()
			f >> t
			if len(t) == 0
				break
			if t in ["# project", "# project name"]
				f >> name
			else if t in ["# binary name", "# binary", "# binary file"]
				f >> binary_file
			else if t == "# main file"
				f >> main_file
			else if t == "# language"
				f >> language
			else if t == "# flags"
				f >> flags_global
			else if t == "# optimization"
				f >> optimization
			else if t == "# build type"
				f >> build_type
			#else if t == "# compiler flags"
#				f >> flags_compiler
#			else if t == "# linker flags"
#				f >> flags_linker
			else if t == "# libraries"
				f >> t
				libs = t.explode(",")
			else if t == "# libraries optional"
				f >> t
				libs_optional = t.explode(",")
			else if t == "# icons"
				f >> t
				icons = t.explode(",")
			else if t == "# desktop file"
				f >> desktop_file
			else if t == "# mime files"
				f >> t
				mime_files = t.explode(",")
			else if t == "# additional install"
				f >> t
				installs = t.explode(",")
			else if t[:10] == "# profile "
				Profile p
				p.name = t[10:]
				f >> t
				p.libs_optional = t.explode(",")
				profiles.add(p)
			else
				raise(new Exception("unknown tag: {{t}}"))
		del f
	void save()
		File* f = Filesystem.create_text(conf.root << "xmake.conf")
		f << "# project"
		f << name
		f << "# binary"
		f << binary_file
		f << "# main file"
		f << main_file
		f << "# language"
		f << language
		f << "# optimization"
		f << optimization
		f << "# build type"
		f << build_type
		f << "# flags"
		f << flags_global
		f << "# libraries"
		f << libs.join(",")
		f << "# libraries optional"
		f << libs_optional.join(",")
		for p in profiles
			f << "# profile {{p.name}}"
			f << p.libs_optional.join(",")
		f << "# icons"
		f << icons.join(",")
		f << "# desktop file"
		f << desktop_file
		f << "# mime files"
		f << mime_files.join(",")
		f << "# additional install"
		f << installs.join(",")
		del f
	
	string[] needs_installing()
		string[] r
		let list = Filesystem.search(Path("../static"), "*.*", true)
		let ignore = mime_files
		ignore.add(desktop_file)
		for e in list
			if not (e in ignore)
				r.add("static/{{e}}")
		for i in installs
#			e.is_dir = Filesystem.is_directory("../{{i}}")
			r.add(i)
		return r

Config conf

class SourceFile
	Path filename
	Path object()
		return Path(str(filename).replace(".cpp", ".o"))
	Path[] dep
	bool add_dep(Path d)
		for dd in dep
			if dd == d
				return false
		dep.add(d)
		return true

SourceFile[] sources

Path rel(Path filename)
	return filename.relative_to(conf.root)


void find_dep(out SourceFile f, Path filename)
	string s
	try
		s = Filesystem.read(filename)
	except
		return
	let lines = s.explode("\n")
	
	for l in lines
		int p = l.find("#include \"", 0)
		if p >= 0
			int q = l.find("\"", p + 11)
			Path d = filename.parent() << l[p+10:q]
			d = d.canonical()
			if Filesystem.exists(d)
				if f.add_dep(d)
					#print("  " + rel(d))
					find_dep(f, d)

void parse_source(Path filename)
	if conf.verbose
		print(rel(filename))
	SourceFile f
	f.filename = filename
	
	find_dep(f, filename)
	
	sources.add(f)

void parse_dir(Path dir)
	let files = Filesystem.search(dir, "*.cpp", true)
	for f in files
		if Filesystem.is_directory(dir << f)
			parse_dir(dir << f)
		else
			parse_source(dir << f)
