func vec_zero(n: int) -> float[]
	var v: float[]
	v.resize(n)
	return v

func vec_basis(n: int, k: int) -> float[]
	var v: float[]
	v.resize(n)
	v[k] = 1
	return v

struct Matrix
	var e: float[]
	var n = 0 # rows
	var m = 0 # cols
	func __init__()
	func __init__(el: float[][])
		n = len(el) # rows
		m = len(el[0]) # columns
		e.resize(n*m)
		for i in 0:n
			for j in 0:m
				e[i*m + j] = el[i][j]
	func mut clear(_n: int, _m: int)
		n = _n
		m = _m
		e.clear()
		e.resize(n*m)
	func selfref get(i: int, j: int) -> float&
		return &e[i * m + j]
	func __str__() -> string
		var s: string[]
		for i in 0:n
			s.add(str(e[i*m:(i+1)*m]))
		return "[" + s.join(",\n ") + "]"
	func mut diagonalize(out b: float[])
		for i in 0:n
			var f = *get(i,i)
			if f == 0
				f = 0.0000001
			#print f
			for j in i:m
				e[i * m + j] /= f
			b[i] /= f
			
			for ii in i+1:n
				var g = *get(ii, i)
				for j in i:m
					e[ii * m + j] -= e[i * m + j] * g
				b[ii] -= b[i] * g
	func solve(b: float[]) -> float[]
		if n != m or len(b) != n
			raise(new Exception("size mismatch"))
		var mm = self
		var x: float[]
		x.resize(m)
		var bb = b
		mm.diagonalize(bb)
		
		var i = n-1
		while i >= 0
			var s = 0.0
			for j in i+1:n
				s += mm.get(i, j) * x[j]
			let f = *mm.get(i, i)
			if abs(f) > 0.00001
				x[i] = (bb[i] - s) # / f
			else
				x[i] = 0
			i --
		return x


func mul(M: Matrix, x: float[]) -> float[]
	if M.m != len(x)
		raise(new Exception("size mismatch"))
	var y: float[]
	y.resize(M.n)
	for i in 0:M.n
		for j=>v in x
			y[i] += M.get(i, j) * v
	return y

func mul(A: Matrix, B: Matrix) -> Matrix
	if A.m != B.n
		raise(new Exception("size mismatch"))
	var r: Matrix
	r.clear(A.n, B.m)
	for i in 0:r.n
		for j in 0:r.m
			var x = 0.0
			for k in 0:A.m
				x += A.get(i,k) * B.get(k,j)
			r.get(i,j) = x
	return r

func inverse(M: Matrix) -> Matrix
	if M.n != M.n
		raise(new Exception("not square"))
	let n = M.n
	var r: Matrix
	r.clear(n, n)
	for i in 0:n
		let e = vec_basis(n, i)
		let a = M.solve(e)
		for j=>v in a
			r.get(j,i) = v
	return r

struct SparseRowMatrix
	var n = 0
	var m = 0
	var rows: (int,float)[][]
	func __init__()
	func __init__(M: Matrix)
		clear(M.n, M.m)
		for i in 0:n
			for j in 0:m
				let v = *M.get(i,j)
				if v != 0
					set(i, j, v)

	func mut clear(_n: int, _m: int)
		n = _n
		m = _m
		rows.clear()
		rows.resize(n)

	func mut set(i: int, j: int, v: float)
		for mut x in rows[j]
			if x[0] == i
				x[1] = v
				return
		if v != 0
			rows[j].add([i, v])

	func get(i: int, j: int) -> float
		for x in rows[j]
			if x[0] == i
				return x[1]
		return 0

	func to_matrix() -> Matrix
		var r: Matrix
		r.clear(n, m)
		for i=>row in rows
			for e in row
				r.get(i,e[0]) = e[1]
		return r

	func __str__() -> string
		var s: string[]
		for row in rows
			s.add(str(row))
		return "[" + s.join(",\n ") + "]"


func mul(M: SparseRowMatrix, x: float[]) -> float[]
	if M.m != len(x)
		raise(new Exception("size mismatch"))
	var y: float[]
	y.resize(M.n)
	for i in 0:M.n
		for el in M.rows[i]
			y[i] += el[1] * x[el[0]]
	return y

func inverse(M: SparseRowMatrix) -> Matrix
	return inverse(M.to_matrix())




# A: inner, B: outer
func outer_product(A: SparseRowMatrix, B: SparseRowMatrix) -> SparseRowMatrix
	var r: Ret
	r.clear(A.n*B.n, A.m*B.m)
		
	for i=>rowA in A.rows
		for j=>rowB in B.rows
			for eA in rowA
				for eB in rowB
					r.set(j*A.n+i, eB[0]*A.n+eA[0], eA[1]*eB[1])
	return r

# ok
func _test_solve()
#func main()
	let M = Matrix([[2.,1.],[-1.,2.]])
	print(M)
	let x = M.solve([1.0,1.0])
	print(x)
	print(mul(M, x))

func _test_mul()
	let M = Matrix([[1,2],[3,4],[5,6]])
	print(M)
	print(mul(M, [1,0]))

func _test_inverse()
#func main()
	let M = Matrix([[2.,1.],[-1.,2.]])
	print(M)
	let I = inverse(M)
	print(I)
	print(mul(I,M))
	print(mul(M,I))

func _test_sparse_mul()
	var M: SparseRowMatrix
	M.clear(4,5)
	M.set(3,2, 5)
	M.set(1,2, 6)
	M.set(3,2, 7)
	print(M)
	print(M.to_matrix())
	print(mul(M, [99,1,1,0,0]))

func _test_outer()
	let A = SparseRowMatrix(Matrix([[1,2],[3,4]]))
	let B = SparseRowMatrix(Matrix([[1,-1],[0,100]]))
	print(A.to_matrix())
	print(B.to_matrix())
	print(outer_product(A, B).to_matrix())
	