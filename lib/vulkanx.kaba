use vulkan
use time
use image

class Vertex
	pos: vector
	n: vector
	u,v: float


func create_quad(r: rect) -> VertexBuffer*
	var vb = new VertexBuffer("3f,3f,2f")
	vb.create_quad(r, rect.ID)
	return vb


class Renderer
	var width, height: int
	#var in_flight_fence: Fence*
	var wait_for_frame_fences: Fence*[]
	var image_available_semaphore, render_finished_semaphore: Semaphore*
	
	var command_buffers: CommandBuffer*[]
	#var cb: CommandBuffer*
	var pool: DescriptorPool*

	func __init__()
		width = 0
		height = 0
		pool = nil
	
		#in_flight_fence = new Fence()
		image_available_semaphore = new Semaphore()
		render_finished_semaphore = new Semaphore()
		#cb = new CommandBuffer()
	
	func virtual __delete__()
		#del in_flight_fence
		del image_available_semaphore
		del render_finished_semaphore
		if pool
			del pool
	
	func const virtual default_render_pass() -> RenderPass*
		return nil
		
	func const virtual current_frame_buffer() -> FrameBuffer*
		return nil
		
	func const virtual current_command_buffer() -> CommandBuffer*
		return nil

	func virtual start_frame() -> bool
		return false

	func virtual end_frame()
		pass
	
	func const area() -> rect
		return rect(0, width, 0, height)


class WindowRenderer extends Renderer
	var window: void*
	var swap_chain: SwapChain*
	var _default_render_pass: RenderPass*
	var depth_buffer: DepthBuffer*
	var frame_buffers: FrameBuffer*[]
	var image_index: int
	var framebuffer_resized: bool
	
	func __init__(_window: void*)
		window = _window
		framebuffer_resized = false
		pool = new DescriptorPool("buffer:1024,sampler:1024", 1024)

		_create_swap_chain_and_stuff()

		#main_renderer = this
	#glfwSetFramebufferSizeCallback(window, framebuffer_resize_callback);

	func override __delete__()
		_delete_swap_chain_and_stuff()

	func _create_swap_chain_and_stuff()
		swap_chain = new SwapChain(window)
		var swap_images = swap_chain.create_textures()
		for t in swap_images
			wait_for_frame_fences.add(new Fence())
			
		for t in swap_images
			command_buffers.add(new CommandBuffer())
			
		depth_buffer = swap_chain.create_depth_buffer()
		_default_render_pass = swap_chain.create_render_pass(depth_buffer)
		frame_buffers = swap_chain.create_frame_buffers(_default_render_pass, depth_buffer)
		width = swap_chain.width
		height = swap_chain.height
	
	func _delete_swap_chain_and_stuff()
		for fb in frame_buffers
			del fb
		del _default_render_pass
		del depth_buffer
		del swap_chain

#void WindowRenderer::framebuffer_resize_callback(GLFWwindow* window, int width, int height) {
#	main_renderer->on_resize(width, height);

#void WindowRenderer::on_resize(int w, int h) {
#	width = w;
#	height = h;
#	framebuffer_resized = true;

	func rebuild_default_stuff()
		print("recreate swap chain")

		default_device.wait_idle()

		_delete_swap_chain_and_stuff()
		_create_swap_chain_and_stuff()
	
	func const override default_render_pass() -> RenderPass*
		return _default_render_pass

	func const override current_frame_buffer() -> FrameBuffer*
		return frame_buffers[image_index]

	func const override current_command_buffer() -> CommandBuffer*
		return command_buffers[image_index]

	func override start_frame() -> bool
		#in_flight_fence.wait()

		if !swap_chain.acquire_image(&image_index, image_available_semaphore)
			rebuild_default_stuff()
			return false
			
		var f = wait_for_frame_fences[image_index]
		f.wait()
		f.reset()
		return true

	func override end_frame()
	#	queue_submit_command_buffer(cb, [image_available_semaphore], [render_finished_semaphore], in_flight_fence)

	#	if !swap_chain.present(image_index, [render_finished_semaphore]) or framebuffer_resized
	#		framebuffer_resized = false
	#		rebuild_default_stuff()
			
			
		var f = wait_for_frame_fences[image_index]
		default_device.present_queue.submit(command_buffers[image_index], [image_available_semaphore], [render_finished_semaphore], f)

		swap_chain.present(image_index, [render_finished_semaphore])
			
		default_device.wait_idle()














class TextureRenderer extends Renderer
	var tex: Texture*
	var depth_buffer: DepthBuffer*
	var frame_buffer: FrameBuffer*
	var _default_render_pass: RenderPass*


	func __init__(t: Texture*)
		tex = t
		width = tex.width
		height = tex.height

		#vulkan::next_compare_op = VK_COMPARE_OP_LESS;
		depth_buffer = new DepthBuffer(width, height, "d:f32", true)
		#vulkan::next_compare_op = VK_COMPARE_OP_ALWAYS;

		_default_render_pass = new RenderPass(["rgba:i8", "d:f32"], "clear")
		frame_buffer = new FrameBuffer(_default_render_pass, [tex.view, depth_buffer.view])


	func override __delete__()
		del _default_render_pass
		del depth_buffer
		del frame_buffer
		del tex

	func override start_frame() -> bool
		#cb.begin()
		return true

	func override end_frame()
		#cb->barrier([tex, depth_buffer], 0);
	#	cb.barrier([depth_buffer], 0)
	#	cb.end()

	#	queue_submit_command_buffer(cb, [], [], in_flight_fence)
	#	in_flight_fence.wait()
		default_device.wait_idle()


	func override current_frame_buffer() -> FrameBuffer*
		return frame_buffer






class UBO
	var m,v,p: matrix

class StatLayer
	var tex: Texture*
	var ubo: UniformBuffer*
	var dset: DescriptorSet*
	var timer: Timer*
	var im: Image*
	var vb: VertexBuffer*
	var pipeline: Pipeline*
	var frames: int
	var _time: float
	
	func __init__(shader: Shader*, rp: RenderPass*, subpass: int, pool: DescriptorPool*)
		timer = new Timer()
		_time = 0
		frames = 0
		im = new Image(256, 64, color(0,0,0,0))
		tex = new Texture()
		tex.override(im)
		ubo = new UniformBuffer(64*3)
		UBO u
		u.p = matrix.ID
		u.v = matrix.ID
		u.m = matrix.ID
		ubo.update(&u)
		dset = pool.create_set("buffer,sampler")
		dset.set_buffer(0, ubo)
		dset.set_texture(1, tex)
		dset.update()
		vb = create_quad(rect(-1,-0.3,-1,-0.8))
		pipeline = new Pipeline(shader, rp, subpass, "triangles", "3f,3f,2f")
		pipeline.set_blend(6,7)
		pipeline.set_z(false, false)
		pipeline.rebuild()
	func __delete__()
		del timer
		del ubo
		del tex
		del dset
		del vb
		del pipeline
	func tick()
		float dt = timer.get()
		_time += dt
		frames ++
		if _time < 0.1
			return
		
		im.create(256, 64, color(0,1,1,1))
		var pp = im.start_draw()
		pp.set_color(color.WHITE)
		pp.set_font_size(20)
		pp.draw_str([5,5], "{{frames/_time|1}}")
		del pp
		tex.override(im)
		dset.set_texture(1, tex)
		dset.update()
		frames = 0
		_time = 0
	func draw(out cb: CommandBuffer)
		cb.bind_pipeline(pipeline)
		cb.bind_descriptor_set(0, dset)
		cb.draw(vb)
		
		
		
