use common

# always copy
func subst_variable(_t: shared Term, _var: string, by: shared Term) -> shared Term
	var t = _t.shallow_copy()
	for p in t.params
		p = subst_variable(p, _var, by)
	
	if t.type == TYPE_VARIABLE
		if t.name == _var
			return by
	return t



class MatchingTerm
	var t: shared Term
	var name: string
	func const __str__() -> string
		return "{{name}} -> {{t}}"

class Matching
	var terms: MatchingTerm[]
	func add(t: shared Term, name: string) -> bool
		#print("add: {{t}} <<< {{name}}")
		MatchingTerm mt
		mt.t = t
		mt.name = name
		terms.add(mt)
		return true
	func const __str__() -> string
		return str([for t in terms str(t)])
	

func rule_match(t: shared Term, m: shared Term, out mm: Matching) -> bool
	if m.name[:1] == "@"
		mm.add(t, m.name)
		return true
	if t.name != m.name
		return false
	if len(t.params) != len(m.params)
		return false
	for p,i in t.params
		if !rule_match(p, m.params[i], mm)
			return false
	return true

func subst(_t: shared Term, pattern: shared Term, substitution: shared Term, max_recursion: int) -> shared Term
	Matching mm
	var t = _t.shallow_copy()
	for p in t.params
		p = subst(p, pattern, substitution, max_recursion)
		
	if rule_match(t, pattern, mm)
		#print("MATCH!!!!")
		#print(str(mm))
		
		var r = substitution
		for x in mm.terms
			r = subst_variable(r, x.name, x.t)
		if max_recursion > 0
			return subst(r, pattern, substitution, max_recursion-1)
		return r
	
	return t