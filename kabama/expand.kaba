use common
use parser

# "out" because of copy().... :P
shared Term expand(shared Term _t)
	# rekursiv
	let t = _t.shallow_copy()
	for p in t.params
		p = expand(p)

	# selbst
	if t.name == "*"
		let p1 = t.params[0]
		let p2 = t.params[1]
		
		if (p1.name == "+") or (p1.name == "-")
			# (x + y) * z  ->  x * z + y * z
			let t_l = t.shallow_copy()
			t_l.params[0] = p1.params[0]
			t_l.params[1] = p2
			let t_r = t.shallow_copy()
			t_r.params[0] = p1.params[1]
			t_r.params[1] = p2
			let t_sum = p1.shallow_copy()
			t_sum.params[0] = t_l
			t_sum.params[1] = t_r
			#print ExprToStr(t_sum)
			return expand(t_sum)
		else if (p2.name == "+") or (p2.name == "-")
			# z * (x + y)  ->  z * x + z * y
			let t_l = t.shallow_copy()
			t_l.params[0] = p1
			t_l.params[1] = p2.params[0]
			let t_r = t.shallow_copy()
			t_r.params[0] = p1
			t_r.params[1] = p2.params[1]
			let t_sum = p2.shallow_copy()
			t_sum.params[0] = t_l
			t_sum.params[1] = t_r
			return expand(t_sum)
	else if t.name == "^"
		let p1 = t.params[0]
		let p2 = t.params[1]
		if p2.type == TYPE_NUMBER
			if p1.name == "*"
				# (a * b)^c  ->  a^c * b^c
				let t_l = t.shallow_copy()
				t_l.params[0] = p1.params[0]
				t_l.params[1] = p2
				let t_r = t.shallow_copy()
				t_r.params[0] = p1.params[1]
				t_r.params[1] = p2
				let t_mul = p1.shallow_copy()
				t_mul.params[0] = t_l
				t_mul.params[1] = t_r
				return expand(t_mul)
			else if (p1.name == "+") or (p1.name == "-")
				int e = int(p2.name)
				let t_mul = p1.copy()
				for i in 1:e
					let t_l = t_mul
					let t_r = p1.copy()
					t_mul = AddOperator("*", t_l, t_r)
				return expand(t_mul)
		if p1.name == "^"
			# (a ^ b) ^ c -> a ^ (b * c)
			let t_mul = AddOperator("*", p1.params[1], p2)
			t = AddOperator("^", p1.params[0], t_mul)
			return expand(t)
		
	return t
