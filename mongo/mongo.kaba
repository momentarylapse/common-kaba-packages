use bson.*

func extern _mongoc_init()
func extern _mongoc_cleanup()
func extern _mongoc_client_new(uri: u8*) -> void*
func extern _mongoc_client_get_collection(client: void*, db: u8*, col: u8*) -> void*
func extern _mongoc_collection_find_with_opts(col: void*, filter: void*, _opts: void*, _prefs: void*) -> void*
func extern _mongoc_collection_aggregate(col: void*, flags: int, pipeline: void*, x: void*, y: void*) -> void*
func extern _mongoc_collection_insert_one(col: void*, doc: void*, _opts: void*, _reply: void*, _err: void*) -> bool
func extern _mongoc_collection_replace_one(col: void*, sel: void*, doc: void*, opts: void*, reply: void*, err: void*) -> bool
func extern _mongoc_collection_delete_one(col: void*, sel: void*, opts: void*, reply: void*, err: void*) -> bool
func extern _mongoc_collection_delete_many(col: void*, sel: void*, opts: void*, reply: void*, err: void*) -> bool
func extern _mongoc_cursor_next(cur: void*, bson: void*) -> bool
func extern _mongoc_cursor_destroy(cur: void*)
func extern _mongoc_collection_destroy(col: void*)
func extern _mongoc_client_destroy(client: void*)


class Mongo as shared
	var client: void*
	func __init__(host: string)
		_any_allow_simple_output = false
		_mongoc_init()
		client = __mongo_client_new("mongodb://{{host}}:27017/?appname=kaba")
		if !client
			raise(new Exception("can not connect to {{host}}"))

	func __delete__()
		if client
			_mongoc_client_destroy(client)
		_mongoc_cleanup()

	func collection(db: string, col: string) -> xfer[Collection]
		var c = new Collection()
		c.col = __mongoc_client_get_collection(client, db, col)
		if !c.col
			raise(new Exception("can not open collection"))
		return give(c)


class Collection as shared
	var col: void* = nil
	func __delete__()
		if col
			_mongoc_collection_destroy(col)
	func find(filter: Any) -> xfer[Result]
		var b = json_to_bson(repr(filter))
		return new Result(_mongoc_collection_find_with_opts(col, b, nil, nil))
	func aggregate(pattern: Any) -> xfer[Result]
		var b = json_to_bson(repr(pattern))
		return new Result(_mongoc_collection_aggregate(col, 0, b, nil, nil))
	func insert(doc: Any)
		var b = json_to_bson(repr(doc))
		if !_mongoc_collection_insert_one(col, b, nil, nil, nil)
			raise(new Exception("can not insert"))
	func replace(filter: Any, doc: Any)
		var b = json_to_bson(repr(filter))
		var d = json_to_bson(repr(doc))
		if !_mongoc_collection_replace_one(col, b, d, nil, nil, nil)
			raise(new Exception("can not replace"))
	func delete_one(filter: Any)
		var b = json_to_bson(repr(filter))
		if !_mongoc_collection_delete_one(col, b, nil, nil, nil)
			raise(new Exception("can not delete"))
	func delete_many(filter: Any)
		var b = json_to_bson(repr(filter))
		var reply: int[160]
		if !_mongoc_collection_delete_many(col, b, nil, &reply, nil)
			raise(new Exception("can not delete"))
		var r = bson_to_any(&reply)
		print(repr(r))

class Result as shared
	var cur: void*
	var doc: void*
	func __init__(_cur: void*)
		cur = _cur
	func __delete__()
		if cur
			_mongoc_cursor_destroy(cur)
	func has_more() -> bool
		return _mongoc_cursor_next(cur, &doc)
		# bson_to_json(doc)
	func json() -> string
		return bson_to_json(doc)
	func get() -> Any
		return bson_to_any(doc)


func __mongo_client_new(uri: string) -> void*
	var t = uri
	t.add(0)
	return _mongoc_client_new(&t[0])

func __mongoc_client_get_collection(client: void*, db: string, col: string) -> void*
	var t1 = db
	t1.add(0)
	var t2 = col
	t2.add(0)
	return _mongoc_client_get_collection(client, &t1[0], &t2[0])



