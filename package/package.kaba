use os
use hui
use kaba

struct Source
	type: string
	name: string
	url: string
	
	func base_path() -> os.Path
		if type == "repo"
			return conf.repos_base | name
		if type == "local"
			return url
		return ""

enum Location
	INTERNAL
	INSTALLED
	REMOTE

struct Package
	name: string
	version: string
	installed: os.Path
	source: os.Path
	location: Location
	

struct Config
	var kaba_base: os.Path
	var packages_base: os.Path
	var repos_base: os.Path
	var sources: Source[]
	var packages_installed: Package[]
	var packages_remote: Package[]
	var verbose = false
var conf: Config


func load_basic_config()
	conf.kaba_base = hui.app_directory
	conf.packages_base = conf.kaba_base | "packages"
	conf.repos_base = conf.kaba_base | "repos"
	
	if not os.fs.is_directory(conf.packages_base)
		os.fs.create_directory(conf.packages_base)
	if not os.fs.is_directory(conf.repos_base)
		os.fs.create_directory(conf.repos_base)
	
	if os.fs.exists(conf.kaba_base | "sources")
		let s = os.fs.read_text(conf.kaba_base | "sources")
		for l in s.explode("\n")
			let x = l.replace("\t", " ").explode(" ")
			if len(x) >= 3
				conf.sources.add([x[0], x[1].replace("/", "."), x[2]])


func find_internal_packages() -> Package[]
	var r: Package[]
	for p in kaba.default_context.packages
		# TODO version!
		r.add([p.name, "0.1", "", "", Location.INTERNAL])
	return r

func read_package(name: string, dir: os.Path, location: Location) -> Package
	var p: Package
	p.name = name
	p.version = "0.1"
	if location == Location.INSTALLED
		p.installed = dir
	else
		p.source = dir
		
	if os.fs.exists(dir | ".kaba-package")
		let ss = os.fs.read_text(dir | ".kaba-package")
		for l in ss.explode("\n")
			let x = l.explode(" ")
			if len(x) < 2
				continue
			if x[0] == "version"
				p.version = x[1]
	p.location = location
	return p


func find_remote_packages() -> Package[]
	var r: Package[]
	for s in conf.sources
		let base = s.base_path()
		if base == ""
			continue
		if not os.fs.exists(base | ".kaba-package")
			continue
		let ss = os.fs.read_text(base | ".kaba-package")
		for l in ss.explode("\n")
			let x = l.explode(" ")
			if len(x) < 2
				continue
			if x[0] == ""
				continue
			var name = os.Path(x[1]).basename().replace(".kaba", "")
			
			r.add(read_package(name, base | x[1], Location.REMOTE))
	return r


func find_installed_packages() -> Package[]
	var r: Package[]
	let list = os.fs.search(conf.packages_base, "*", "d")
	for e in list
		r.add(read_package(str(e), conf.packages_base | e, Location.INSTALLED))
	return r


func list_find(list: Package[], name: string) -> Package*
	for p in list
		if p.name == name
			return &p
	return nil


func file_equal(a: os.Path, b: os.Path) -> bool
	if not os.fs.exists(a) or not os.fs.exists(b)
		return false
	let sa = os.fs.read(a)
	let sb = os.fs.read(b)
	return sa == sb


func check_package(p: Package) -> bool
	if str(p.source)[-5:] == ".kaba"
		return file_equal(p.source, p.installed)
	
	######## TODO CHECK DIR....
	return true


func load_module_list()
	let internal = find_internal_packages()
	var installed = find_installed_packages()
	conf.packages_remote = find_remote_packages()
	
	conf.packages_installed = installed
	for p in internal
		conf.packages_installed.add(p)
	
#	conf.packages = internal
#	
#	for mut p in installed
#		for pp in list_find(from_sources, p.name)
#			p.state = State.INSTALLED
#			p.source = pp.source
#			if p.version != pp.version
#				p.state = State.INSTALLED_DIFF
#		else
#			p.state = State.NOT_MANAGED
#		conf.packages.add(p)
#		
#	for p in from_sources
#		for pp in list_find(installed, p.name)
#			pass
#		else
#			conf.packages.add(p)


func action_update(args: string[])
	for s in conf.sources
		if s.type != "repo"
			continue
		
		print("updating package {{s.name}}")
		let base = conf.repos_base | s.name
		if not os.fs.is_directory(base)
			os.fs.create_directory(base)
		let git = base | ".git" # FIXME bug in kaba!!!!
		if not os.fs.is_directory(base | ".git")
			let r = os.shell_execute("cd {{base}}; git clone {{s.url}} .")
		let r = os.shell_execute("cd {{base}}; git pull")


func action_list(args: string[])
	load_module_list()
	
	var packages = conf.packages_installed
	for p in conf.packages_remote
		for pp in list_find(conf.packages_installed, p.name)
			pass
		else
			packages.add(p)

	for p in packages |> sort("name")
		var s = ""
		if p.location == Location.INTERNAL
			s = "{{os.terminal.GRAY}}internal{{os.terminal.END}}"
		if p.location == Location.INSTALLED
			s = "{{os.terminal.GREEN}}installed{{os.terminal.END}}"
			for pp in list_find(conf.packages_remote, p.name)
				if pp.version != p.version
					s = "{{os.terminal.RED}}installed, can upgraded to {{pp.version}}{{os.terminal.END}}"
			else
				s = "{{os.terminal.RED}}unmanaged{{os.terminal.END}}"
		print("{{p.name|16}}  {{p.version|-4}} {{s}}")


func delete_directory(dir: os.Path)
#	let list = os.fs.search(dir, "*", "rf")
#	for e in list
#		let f = dir | e
#		#if conf.verbose
#		#	print("{{os.terminal.YELLOW}}deleting{{os.terminal.END}} {{f}}")
#		os.fs.delete(f)
#	let listd = os.fs.search(dir, "*", "rd")
#	print(listd)
#	for e in listd
#		let f = dir | e
#		#if conf.verbose
#		#	print("{{os.terminal.YELLOW}}deleting{{os.terminal.END}} {{f}}")
#		os.fs.delete_directory(f)
#	os.fs.delete_directory(dir)
	let r = os.shell_execute("rm -rf '{{dir}}'")

func remove_package(p: Package)
	print("{{os.terminal.YELLOW}}deleting{{os.terminal.END}} {{p.installed}}")
	delete_directory(p.installed)


func allow_install_file(f: os.Path) -> bool
	let pp = f.all_parents()
	var b = str(f)
	if len(pp) > 0
		b = str(pp[len(pp) - 1]).replace("/", "")
	#print("{{f}}  {{b}}")
	if b in ["src", "build", "CMakeLists.txt", "CMakePresets.json", ".vs", "xmake.conf", "vcpkg-configuration.json", "vcpkg.json"]
		return false
	
	return true

func install_package(p: Package)
# TODO REMOVE
#	if p.state == State.INSTALLED
#		remove_package(p)
		
	let dest = conf.packages_base | p.name
		
	if os.fs.is_directory(dest)
		delete_directory(p.installed)
	os.fs.create_directory(dest)

	if os.fs.exists(p.source | "xmake.conf")
		if os.fs.is_directory(p.source | "build")
			delete_directory(p.source | "build")
		print("build...")
		let r = os.shell_execute("cd '{{p.source}}'; mkdir build; cd build; cmake .. -GNinja && ninja && cp libmodule* '{{dest}}'", true)
			
	let listd = os.fs.search(p.source, "*", "rd")
	for e in listd
		if allow_install_file(e)
			os.fs.create_directory(dest | e)
		
	let list = os.fs.search(p.source, "*", "rf")
	for e in list
		if allow_install_file(e)
			let a = p.source | e
			let b = dest | e
			if conf.verbose
				print("{{os.terminal.YELLOW}}copy{{os.terminal.END}} {{a}}  ->  {{b}}")
			os.fs.copy(a, b)


func action_install(args: string[])
	load_module_list()
	for name in args
		for p in list_find(conf.packages_installed, name)
			if p.location == Location.INTERNAL
				print("{{os.terminal.RED}}internal packages can not be installed{{os.terminal.END}}")
				return
				
		for p in list_find(conf.packages_remote, name)
			install_package(p)
		else
			print("{{os.terminal.RED}}package not found{{os.terminal.END}}")


func action_remove(args: string[])
	load_module_list()
	for name in args
		for p in list_find(conf.packages_installed, name)
			if p.location == Location.INTERNAL
				print("{{os.terminal.RED}}internal packages can not be remove{{os.terminal.END}}")
				return
			else
				remove_package(p)
		else
			print("{{os.terminal.RED}}package not found{{os.terminal.END}}")


func main(args: string[])
	load_basic_config()

	var p: os.CommandLineParser
	p.info("package", "kaba package manager")
	p.option("-v", "verbose", func() conf.verbose = true)
	
	p.cmd("update", "", "update database / repositories", action_update)
	p.cmd("list", "", "list available packages", action_list)
	p.cmd("install", "NAME", "install package", action_install)
	p.cmd("remove", "NAME", "remove package", action_remove)
	p.parse(args)
