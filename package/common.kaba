use os
use kaba

let REPO_FILE = ".kaba-repo"
let PACKAGE_FILE = ".kaba-package"

struct Source
	type: string
	name: string
	url: string
	
	func base_path() -> os.Path
		if type == "repo"
			return conf.repos_base | name
		if type == "local"
			return url
		return ""

enum Location
	INTERNAL
	INSTALLED
	REMOTE

struct Package
	name: string
	version: string
	base_installed: os.Path
	base_source: os.Path # location of the source package
	root_source: os.Path # actual root of files to copy in source (might be child of base_source)
	build_mode: string?
	build_dir: string
	build_target: string
	location: Location
	requires: string[]
	func mut __init__() # kaba ARM workaround...
	

class Config
	var kaba_base: os.Path
	var packages_base: os.Path
	var repos_base: os.Path
	var sources: Source[]
	var packages_internal: Package[]
	var packages_installed: Package[]
	var packages_remote: Package[]
	var verbose = false
	var keep_build_dir = false
var conf: Config


func load_basic_config()
	conf.kaba_base = os.app_directory_dynamic
	conf.packages_base = conf.kaba_base | "packages"
	conf.repos_base = conf.kaba_base | "repos"
	
	if not os.fs.is_directory(conf.packages_base)
		os.fs.create_directory(conf.packages_base)
	if not os.fs.is_directory(conf.repos_base)
		os.fs.create_directory(conf.repos_base)
	
	if os.fs.exists(conf.kaba_base | "sources")
		let s = os.fs.read_text(conf.kaba_base | "sources")
		for l in s.explode("\n")
			let x = l.replace("\t", " ").explode(" ")
			if len(x) >= 3
				conf.sources.add([x[0], x[1].replace("/", "."), x[2]])


func find_internal_packages() -> Package[]
	var r: Package[]
	for p in kaba.default_context.packages
		var pp: Package
		pp.name = p.name
		pp.version = "0" # TODO
		pp.location = Location.INTERNAL
		r.add(pp)
	return r


func read_package(name: string, dir: os.Path, location: Location) -> Package
	var p: Package
	p.name = name
	p.version = "0"
	
	p.base_installed = conf.packages_base | name
	if location == Location.INSTALLED
		p.base_installed = dir
	else
		p.base_source = dir
		p.root_source = dir
		
	if os.fs.exists(dir | PACKAGE_FILE)
		let ss = os.fs.read_text(dir | PACKAGE_FILE)
		for l in ss.explode("\n")
			let x = l.explode(" ")
			if len(x) < 2
				continue
			if x[0] == "version"
				p.version = x[1]
			else if x[0] == "requires"
				p.requires.add(x[1])
			else if x[0] == "root"
				p.root_source = p.base_source | x[1]
			else if x[0] == "build" and len(x) >= 4
				p.build_mode = x[1]
				p.build_dir = x[2]
				p.build_target = x[3]
	p.location = location
	return p


func find_remote_packages() -> Package[]
	var r: Package[]
	for s in conf.sources
		let base = s.base_path()
		if base == ""
			continue
		if not os.fs.exists(base | REPO_FILE)
			continue
		let ss = os.fs.read_text(base | REPO_FILE)
		for l in ss.explode("\n")
			let x = l.explode(" ")
			if len(x) < 2
				continue
			if x[0] != "package"
				continue
			var name = os.Path(x[1]).basename().replace(".kaba", "")
			let p = read_package(name, base | x[1], Location.REMOTE)
			for pp in list_find(r, name)
				print("   MULTIPLE SOURCES FOR {{name}}:  {{p.base_source}}  {{pp.base_source}}")
			else
				r.add(p)
	return r


func find_installed_packages() -> Package[]
	var r: Package[]
	let list = os.fs.search(conf.packages_base, "*", "d")
	for e in list
		r.add(read_package(str(e), conf.packages_base | e, Location.INSTALLED))
	return r


func list_find(list: Package[], name: string) -> Package*
	for p in list
		if p.name == name
			return &p
	return nil


func file_equal(a: os.Path, b: os.Path) -> bool
	if not os.fs.exists(a) or not os.fs.exists(b)
		return false
	let sa = os.fs.read(a)
	let sb = os.fs.read(b)
	return sa == sb


func load_module_list()
	conf.packages_internal = find_internal_packages()
	conf.packages_installed = find_installed_packages()
	conf.packages_remote = find_remote_packages()


func is_installed_latest(name: string) -> bool
	for p in list_find(conf.packages_internal, name)
		return true
	for p in list_find(conf.packages_installed, name)
		for pp in list_find(conf.packages_remote, p.name)
			return pp.version == p.version
		# no remote? ...not sure
		return true
	# not installed
	return false


func delete_directory(dir: os.Path)
#	let list = os.fs.search(dir, "*", "rf")
#	for e in list
#		let f = dir | e
#		#if conf.verbose
#		#	print("{{os.terminal.YELLOW}}deleting{{os.terminal.END}} {{f}}")
#		os.fs.delete(f)
#	let listd = os.fs.search(dir, "*", "rd")
#	print(listd)
#	for e in listd
#		let f = dir | e
#		#if conf.verbose
#		#	print("{{os.terminal.YELLOW}}deleting{{os.terminal.END}} {{f}}")
#		os.fs.delete_directory(f)
#	os.fs.delete_directory(dir)
	let r = os.shell_execute("rm -rf '{{dir}}'")

