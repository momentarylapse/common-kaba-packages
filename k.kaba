const int CHAR_NL = 0x0a
const int CHAR_TAB = 0x09

bool verbose

bool isWhitespace(char c)
	return (c == ' ') or (c == CHAR_TAB) or (c == CHAR_NL)

bool isNumber(char c)
	return (c >= '0') and (c <= '9')

bool isOperator(char c)
	return (c == '(') or (c == ')') or (c == '=') or (c == '+') or (c == '-') or (c == '*') or (c == '/') or (c == '%') or (c == '.') or (c == ',') or (c == '[') or (c == ']') or (c == '!') or (c == '<') or (c == '>')


string unescape(string s)
	string r
	for j in 1:s.num-1
		if s[j] == '\' and j < s.num + 1
			j ++
			if s[j] == 'n'
				r.add(CHAR_NL)
			if s[j] == 't'
				r.add(CHAR_TAB)
			if s[j] == '\'
				r.add('\')
		else
			r.add(s[j])
	return r

class Line
	int indent
	int physical_line_no
	string[] words
	void show()
		print(indent)
		print(words)

class Lines
	Line[] lines
	void show()
		for l in lines
			l.show()

class LiteralParser
	string getWord(string source, int i0)
		string r
		for j in i0:source.num
			if isWhitespace(source[j])
				break
			if isOperator(source[j])
				break
			r.add(source[j])
		return r

	string getNumber(string source, int i0)
		string r
		for j in i0:source.num
			if !isNumber(source[j]) and (source[j] != '.')
				break
			r.add(source[j])
		return r
		
	string getString(string source, int i0)
		string r
		r.add(source[i0])
		for j in i0+1:source.num
			if source[j] == '\' and j < source.num + 1
				r.add(source[j])
				r.add(source[j+1])
				j ++
			else
				r.add(source[j])
				if source[j] == '"' // "
					break
		return r

	string getOperator(string source, int i0)
		string r
		r.add(source[i0])
		if source.num > i0 + 1
			if source[i0 + 1] == '='
				if source[i0] == '=' or source[i0] == '+' or source[i0] == '-' or source[i0] == '*' or source[i0] == '/' or source[i0] == '<' or source[i0] == '>'
					r.add(source[i0 + 1])
		return r
	
	Line parseLine(string source)
		Line l
		l.indent = 0
		for i in 0:source.num
			l.indent = i
			if source[i] != CHAR_TAB
				break
		string temp
		for i in l.indent:source.num
			if isWhitespace(source[i])
				continue
			if source[i] == '"' // "
				temp = getString(source, i)
			else if isNumber(source[i])
				temp = getNumber(source, i)
			else if isOperator(source[i])
				temp = getOperator(source, i)
			else
				temp = getWord(source, i)
			l.words.add(temp)
			i += temp.num-1
		return l

	Lines parse(string source)
		Lines r
		string[] lines = source.explode("\n")
		int line_no = 0
		for l in lines
			Line ll = parseLine(l)
			if ll.words.num > 0
				ll.physical_line_no = line_no
				r.lines.add(ll)
			line_no ++
		return r

enum
	TYPE_NONE
	TYPE_BOOL
	TYPE_INT
	TYPE_FLOAT
	TYPE_STRING
	TYPE_ARRAY
	TYPE_OBJECT

class DynamicValue
	int type
	void __init__()
		type = TYPE_NONE
	virtual void __delete__()
	virtual string str()
		return "nil"
	virtual int int()
		return 0
	virtual float float()
		return 0.0
	virtual bool bool()
		return false

class DynamicValueInt extends DynamicValue
	int v
	override void __init__()
		type = TYPE_INT
		v = 0
	override void __delete__()
	override string str()
		return v.str()
	override int int()
		return v
	override float float()
		return v

class DynamicValueBool extends DynamicValue
	bool v
	override void __init__()
		type = TYPE_BOOL
		v = false
	override void __delete__()
	override string str()
		return v.str()
	override bool bool()
		return v

class DynamicValueFloat extends DynamicValue
	float v
	override void __init__()
		type = TYPE_FLOAT
		v = 0.0
	override void __delete__()
	override string str()
		return v.str()
	override int int()
		return v
	override float float()
		return v

class DynamicValueString extends DynamicValue
	string v
	override void __init__()
		type = TYPE_STRING
		v.__init__()
	override void __delete__()
	override string str()
		return v
	override bool bool()
		return v.num > 0

class Variable
	string name
	bool writable
	DynamicValue *v
	void __init__()
		v = new DynamicValue
		writable = true
	void __init__(string _name)
		name = _name
		v = new DynamicValue
		writable = true
	void __delete__()
		delete v
	void show()
		string s
		if writable
			s += "variable "
		else
			s += "const "
		
		if v.type == TYPE_BOOL
			s += "bool "
		else if v.type == TYPE_INT
			s += "int "
		else if v.type == TYPE_FLOAT
			s += "float "
		else if v.type == TYPE_STRING
			s += "string "
		else
			s += "??? "
		if name.num > 0
			s += name + " = "
		if v.type == TYPE_STRING
			s += "'"
		s += v.str()
		if v.type == TYPE_STRING
			s += "'"
		print(s)
	void setType(int _type)
		if v.type != _type
			delete v
			if _type == TYPE_BOOL
				v = new DynamicValueBool
			else if _type == TYPE_INT
				v = new DynamicValueInt
			else if _type == TYPE_FLOAT
				v = new DynamicValueFloat
			else if _type == TYPE_STRING
				v = new DynamicValueString
			else
				v = new DynamicValue
	void setBool(bool b)
		setType(TYPE_BOOL)
		DynamicValueBool *vb = v
		vb.v = b
	void setInt(int i)
		setType(TYPE_INT)
		DynamicValueInt *vi = v
		vi.v = i
	void setFloat(float f)
		setType(TYPE_FLOAT)
		DynamicValueFloat *vf = v
		vf.v = f
	void setString(string s)
		setType(TYPE_STRING)
		DynamicValueString *vs = v
		vs.v = s
		

	void __assign__(Variable b)
		if b.v.type == TYPE_BOOL
			setBool(b.v.bool())
		else if b.v.type == TYPE_INT
			setInt(b.v.int())
		else if b.v.type == TYPE_FLOAT
			setFloat(b.v.float())
		else if b.v.type == TYPE_STRING
			setString(b.v.str())

	void __iadd__(Variable b)
		if b.v.type == TYPE_INT
			if v.type == TYPE_INT
				setInt(v.int() + b.v.int())
			else if v.type == TYPE_FLOAT
				setInt(v.int() + b.v.float())
		else if b.v.type == TYPE_FLOAT
			if v.type == TYPE_INT
				setFloat(v.float() + b.v.int())
			else if v.type == TYPE_FLOAT
				setFloat(v.float() + b.v.float())
		else if b.v.type == TYPE_STRING
			if v.type == TYPE_STRING
				setString(v.str() + b.v.str())

	void __isub__(Variable b)
		if b.v.type == TYPE_INT
			DynamicValueInt *bi = b.v
			if v.type == TYPE_INT
				DynamicValueInt *ai = v
				ai.v -= bi.v
			else if v.type == TYPE_FLOAT
				DynamicValueFloat *af = v
				af.v -= bi.v
		else if b.v.type == TYPE_FLOAT
			DynamicValueFloat *bf = b.v
			if v.type == TYPE_INT
				DynamicValueInt* ai = v
				setFloat(ai.v - bf.v)
			else if v.type == TYPE_FLOAT
				DynamicValueFloat* af = v
				af.v -= bf.v

	void __imul__(Variable b)
		if b.v.type == TYPE_INT
			DynamicValueInt *bi = b.v
			if v.type == TYPE_INT
				DynamicValueInt *ai = v
//				ai.v *= bi.v
				ai.v = ai.v * bi.v
			else if v.type == TYPE_FLOAT
				DynamicValueFloat *af = v
				af.v *= bi.v
		else if b.v.type == TYPE_FLOAT
			DynamicValueFloat *bf = b.v
			if v.type == TYPE_INT
				DynamicValueInt* ai = v
				setFloat(ai.v * bf.v)
			else if v.type == TYPE_FLOAT
				DynamicValueFloat* af = v
				af.v *= bf.v

	void __idiv__(Variable b)
		if b.v.type == TYPE_INT
			DynamicValueInt *bi = b.v
			if v.type == TYPE_INT
				DynamicValueInt *ai = v
				ai.v /= bi.v
			else if v.type == TYPE_FLOAT
				DynamicValueFloat *af = v
				af.v /= bi.v
		else if b.v.type == TYPE_FLOAT
			DynamicValueFloat *bf = b.v
			if v.type == TYPE_INT
				DynamicValueInt* ai = v
				setFloat(ai.v / bf.v)
			else if v.type == TYPE_FLOAT
				DynamicValueFloat* af = v
				af.v /= bf.v

	int compare(Variable b)
		if b.v.type == TYPE_INT
			DynamicValueInt *bi = b.v
			if v.type == TYPE_INT
				DynamicValueInt *ai = v
				return ai.v - bi.v
			else if v.type == TYPE_FLOAT
				DynamicValueFloat *af = v
				return (af.v - bi.v)*1000.0
		else if b.v.type == TYPE_FLOAT
			DynamicValueFloat *bf = b.v
			if v.type == TYPE_INT
				DynamicValueInt* ai = v
				return (ai.v - bf.v)*1000.0
			else if v.type == TYPE_FLOAT
				DynamicValueFloat* af = v
				return (af.v - bf.v)*1000.0
		else if b.v.type == TYPE_STRING
			DynamicValueString *bs = b.v
			if v.type == TYPE_STRING
				DynamicValueString *as = v
				if as.v < bs.v
					return -1
				if as.v > bs.v
					return 1
				return 0
				//return ai.v.compare(bf.v)
		return 0

class Function
	string name
	Variable*[] params
	Variable*[] vars
	SyntaxNodeBlock* block
	void __init__(string n)
		name = n
		block = nil
	Variable* addVar(string name)
		Variable *v = new Variable(name)
		vars.add(v)
		return v

void FuncSin(Variable* r, Variable*[] p)
	if p[0].v.type == TYPE_FLOAT or p[0].v.type == TYPE_INT
		r.setFloat(sin(p[0].v.float()))

void FuncPrint(Variable *r, Variable*[] p)
	string s
	for pp in p
		s += pp.v.str()
		s += " "
	print(s)

enum
	TYPE_OPERATOR
	TYPE_VARIABLE
	TYPE_FUNCTION
	TYPE_BLOCK
	TYPE_IF
	TYPE_WHILE

class SyntaxNode
	int type
	SyntaxNode*[] params
	virtual string str()
		return "???"
	virtual void showPost(int indent)
	void show(int indent)
		string s
		for i in 0:indent
			s += "    "
		print(s + str())
		for p in params
			p.show(indent + 1)
		showPost(indent)

class SyntaxNodeVariable extends SyntaxNode
	Variable *v
	void __init__(Variable *_v)
		v = _v
		type = TYPE_VARIABLE
	override string str()
		if v.writable
			return "variable " + v.name
		return "const " + v.v.str()

class SyntaxNodeOperator extends SyntaxNode
	string op
	void __init__(string _op)
		op = _op
		type = TYPE_OPERATOR
	override string str()
		return "operator " + op
	int rank()
		if op == "*"
			return 1
		if op == "/"
			return 2
		if op == "+"
			return 3
		if op == "-"
			return 4
		if op == "="
			return 10
		return 5

class SyntaxNodeFunction extends SyntaxNode
	Function* func
	
	void __init__(Function* _func)
		func = _func
		type = TYPE_FUNCTION
	override string str()
		return "function " + func.name

class SyntaxNodeBlock extends SyntaxNode
	override void __init__()
		type = TYPE_BLOCK
	override string str()
		return "block"

class SyntaxNodeIf extends SyntaxNode
	SyntaxNode* block, block_else
	override void __init__()
		type = TYPE_IF
		block = nil
		block_else = nil
	override string str()
		return "if"
	override void showPost(int indent)
		block.show(indent+1)
		if block_else
			block_else.show(indent+1)

class SyntaxNodeWhile extends SyntaxNode
	SyntaxNode* block, block_else
	override void __init__()
		type = TYPE_WHILE
		block = nil
		block_else = nil
	override string str()
		return "while"
	override void showPost(int indent)
		block.show(indent+1)
		if block_else
			block_else.show(indent+1)

class SyntaxTree
	Variable*[] vars
	Function* func_main
	Function*[] funcs
	Function*[] internal_funcs
	
	
	Function* cur_func
	
	
	Lines lines
	int cur_line_no
	Line cur_line
	int cur_word
	string cur
	bool endOfFile()
		return cur_line_no >= lines.lines.num - 1
	void nextLine()
		if endOfFile()
			setError("unexpected end of file")
			return
		cur_line_no ++
		cur_line = lines.lines[cur_line_no]
		cur_word = 0
		cur = cur_line.words[0]
	bool endOfLine()
		return cur_word >= cur_line.words.num - 1
	void next()
		if endOfLine()
			setError("unexpected end of line")
			return
		cur_word ++
		cur = cur_line.words[cur_word]
	
	bool error
	void setError(string msg)
		print("=== error ===")
		print("line " + (cur_line.physical_line_no + 1) + " at " + cur)
		print(msg)
		error = true
	
	Variable* getVar(string name)
		for v in cur_func.vars
			if v.name == name
				return v
		return nil
	Variable* addConstNumber(string s)
		Variable* c = cur_func.addVar("")//s)
		c.writable = false
		if s.find(".", 0) >= 0
			c.setFloat(s.float())
		else
			c.setInt(s.int())
		return c
	Variable* addConstString(string s)
		Variable* c = cur_func.addVar("")//s)
		c.writable = false
		c.setString(s)
		return c
	Function* addFunc(string name)
		Function* f = new Function(name)
		funcs.add(f)
		return f
	Function* getFunc(string name)
		for f in funcs
			if f.name == name
				return f
		for f in internal_funcs
			if f.name == name
				return f
		return nil
	SyntaxNode* getNuclearOperand()
		if isNumber(cur[0])
			return new SyntaxNodeVariable(addConstNumber(cur))
		if cur[0] == '"' // "
			return new SyntaxNodeVariable(addConstString(unescape(cur)))
		if isOperator(cur[0])
			setError("variable name expected")
			return nil
		Variable* v = getVar(cur)
		if v
			return new SyntaxNodeVariable(v)
		
		if cur_word == 0
			if cur_line.words.num >= 2
				if cur_line.words[1] == "="
					return new SyntaxNodeVariable(cur_func.addVar(cur))
		setError("unknown operand")
		return nil
	SyntaxNode* getOperator()
		if !isOperator(cur[0]) and (cur != "and") and (cur != "or")
			setError("operator expected")
			return nil
		return new SyntaxNodeOperator(cur)
	SyntaxNode* getOperandFunc()
		Function* func = getFunc(cur)
		if !func
			setError("unknown function")
			return nil
		SyntaxNode* sn = new SyntaxNodeFunction(func)
		next()
		if error
			return nil
		if cur != "("
			setError("( after function name expected")
			return nil
		next()
		if error
			return nil
		if cur == ")"
			return sn
		while true
			SyntaxNode *param = getOperandGreedy()
			if error
				return nil
			sn.params.add(param)
			next()
			if cur != "," and cur != ")"
				setError(", or ) after parameter expexted")
				return nil
			if cur == ")"
				break
			next()
			if error
				return nil
		return sn
	SyntaxNode* getOperand()
		if cur == "("
			next()
			SyntaxNode *sn = getOperandGreedy()
			next()
			if cur != ")"
				setError(") expected")
				return nil
			return sn
		if cur_word+1 < cur_line.words.num
			if cur_line.words[cur_word+1] == "("
				return getOperandFunc()
		SyntaxNode* sn = getNuclearOperand()
		return sn
	SyntaxNode* getOperandGreedy()
		SyntaxNode*[] sn
		sn.add(getOperand())
		if error
			return nil
		while !endOfLine()
			if cur_line.words[cur_word + 1] == "," or cur_line.words[cur_word + 1] == ")"
				break
			next()
			if error
				return nil
			sn.add(getOperator())
			if error
				return nil
			next()
			if error
				return nil
			sn.add(getOperand())
			if error
				return nil
		return linkOperators(sn)
	SyntaxNode* linkOperators(SyntaxNode*[] sn)
		int[] rank
		for i in 0:(sn.num-1)/2
			SyntaxNodeOperator *op = sn[i*2+1]
			rank.add(op.rank())
		while sn.num > 2
			int rmin = 100, imin = 0
			for r,i in rank
				if r < rmin
					rmin = r
					imin = i
			sn[imin*2+1].params.add(sn[imin*2])
			sn[imin*2+1].params.add(sn[imin*2+2])
			sn.remove(imin*2+2)
			sn.remove(imin*2)
			rank.remove(imin)
		return sn[0]
	SyntaxNode *getSpecialCommandIf()
		int indent0 = cur_line.indent
		SyntaxNodeIf *sn = new SyntaxNodeIf
		next()
		sn.params.add(getOperandGreedy())
		if error
			return nil
		sn.block = parseBlock()
		if error
			return nil
		if endOfFile()
			return sn
		if lines.lines[cur_line_no + 1].indent != indent0 or lines.lines[cur_line_no + 1].words[0] != "else"
			return sn
		nextLine()
		// else
		sn.block_else = parseBlock()
		return sn
	SyntaxNode *getSpecialCommandWhile()
		int indent0 = cur_line.indent
		SyntaxNodeWhile *sn = new SyntaxNodeWhile
		next()
		sn.params.add(getOperandGreedy())
		if error
			return nil
		sn.block = parseBlock()
		if error
			return nil
		if endOfFile()
			return sn
		if lines.lines[cur_line_no + 1].indent != indent0 or lines.lines[cur_line_no + 1].words[0] != "else"
			return sn
		nextLine()
		// else
		sn.block_else = parseBlock()
		return sn
	void parseFunctionDef()
		Function* prev_func = cur_func
		int indent0 = cur_line.indent
		next()
		if error
			return
		Function *func = new Function(cur)
		funcs.add(func)
		cur_func = func
		next()
		if error
			return
		if cur != "("
			setError("( expected")
			return
		next()
		if error
			return
		while cur != ")"
			//Variable* v = ad
			func.params.add(func.addVar(cur))
			next()
			if error
				return
			if cur == ")"
				break
			if cur != ","
				setError(", or ) expected")
				return
			next()
			if error
				return
		if !endOfLine()
			setError("end of line expexted")
			return
		
		func.block = parseBlock()
		cur_func = prev_func
		
	SyntaxNode *parseLine()
		if cur == "if"
			return getSpecialCommandIf()
		if cur == "while"
			return getSpecialCommandWhile()
		if cur == "def"
			parseFunctionDef()
			return nil
		SyntaxNode *sn = getOperandGreedy()
		if error
			return nil
		if !endOfLine()
			setError("end of line expected")
		return sn
	SyntaxNode *parseBlock()
		SyntaxNodeBlock *sn = new SyntaxNodeBlock
		nextLine()
		if error
			return nil
		int indent0 = cur_line.indent
		SyntaxNode *sub = parseLine()
		if error
			return nil
		if sub
			sn.params.add(sub)
		while !endOfFile()
			if lines.lines[cur_line_no + 1].indent < indent0
				return sn
			if lines.lines[cur_line_no + 1].indent > indent0
				sn.params.add(parseBlock())
			else
				nextLine()
				sub = parseLine()
				if sub
					sn.params.add(sub)
			if error
				return nil
		return sn
	
	void create(string source)
		error = false
		LiteralParser lp
		
		func_main = addFunc("main")
		
		Variable* v = func_main.addVar("true")
		v.setBool(true)
		v.writable = false
		v = func_main.addVar("false")
		v.writable = false
		v.setBool(false)
		v = func_main.addVar("nil")
		v.writable = false
		v = func_main.addVar("pi")
		v.setFloat(3.141592654)
		v.writable = false
		
		Function* f = new Function("sin")
		internal_funcs.add(f)
		f = new Function("print")
		internal_funcs.add(f)
		
		lines = lp.parse(source)
		cur_line_no = -1
		//lines.show()
		cur_func = func_main
		func_main.block = parseBlock()
	void show()
		print("--- syntax tree ---")
		for f in funcs
			print("function " + f.name)
			f.block.show(1)
		print("--- ---")
	void showVars()
		print("--- variables ---")
		for v in vars
			v.show()
		for f in funcs
			print(">> " + f.name)
			for v in f.vars
				v.show()
		print("--- ---")

class Interpreter
	SyntaxTree* syntax
	bool error
	void setError(string msg)
		print("=== error during execution ==")
		print(msg)
		error = true
	void doNode(SyntaxNode *sn, Variable *ret)
		Variable*[] params
		bool[] is_temp
		for p in sn.params
			if p.type == TYPE_VARIABLE
				SyntaxNodeVariable *vv = p
				params.add(vv.v)
				is_temp.add(false)
			else
				Variable *temp = new Variable
				doNode(p, temp)
				if error
					return
				params.add(temp)
				is_temp.add(true)
		if sn.type == TYPE_OPERATOR
			SyntaxNodeOperator *op = sn
			if op.op == "="
				*params[0] = *params[1]
			else if op.op == "+"
				*ret = *params[0]
				*ret += *params[1]
			else if op.op == "+="
				*params[0] += *params[1]
			else if op.op == "-"
				*ret = *params[0]
				*ret -= *params[1]
			else if op.op == "-="
				*params[0] -= *params[1]
			else if op.op == "*"
				*ret = *params[0]
				*ret *= *params[1]
			else if op.op == "*="
				*params[0] *= *params[1]
			else if op.op == "/"
				*ret = *params[0]
				*ret /= *params[1]
			else if op.op == "/="
				*params[0] /= *params[1]
			else if op.op == ">"
				ret.setBool(params[0].compare(*params[1]) > 0)
			else if op.op == "<"
				ret.setBool(params[0].compare(*params[1]) < 0)
			else if op.op == "=="
				ret.setBool(params[0].compare(*params[1]) == 0)
			else if op.op == ">="
				ret.setBool(params[0].compare(*params[1]) >= 0)
			else if op.op == "<="
				ret.setBool(params[0].compare(*params[1]) <= 0)
			else if op.op == "and"
				ret.setBool(params[0].v.bool() and params[1].v.bool())
			else if op.op == "or"
				ret.setBool(params[0].v.bool() or params[1].v.bool())
			else if op.op == "not"
				ret.setBool(params[0].v.bool())
			else
				setError("unhandled operator: " + op.op)
		else if sn.type == TYPE_FUNCTION
			SyntaxNodeFunction *func = sn
			if func.func.block
				doNode(func.func.block, ret)
			else
				if func.func.name == "sin"
					FuncSin(ret, params)
				else if func.func.name == "print"
					FuncPrint(ret, params)
				else
					setError("unhandled internal function: " + func.func.name)
		else if sn.type == TYPE_IF
			Variable dummy
			SyntaxNodeIf *_if = sn
			if params[0].v.bool()
				doNode(_if.block, &dummy)
			else if _if.block_else
				doNode(_if.block_else, &dummy)
		else if sn.type == TYPE_WHILE
			Variable dummy
			SyntaxNodeWhile *_while = sn
			while params[0].v.bool()
				doNode(_while.block, &dummy)

				// reevaluate
				if sn.params[0].type != TYPE_VARIABLE
					doNode(sn.params[0], params[0])
					if error
						return
		for p,i in params
			if is_temp[i]
				delete p
	void run(SyntaxTree _syntax)
		syntax = &_syntax
		error = false
		Variable dummy
		doNode(syntax.func_main.block, &dummy)

void eval(string source)
	SyntaxTree syntax
	syntax.create(source)
	if syntax.error
		return
	if verbose
		syntax.show()
	Interpreter inter
	inter.run(syntax)
	if verbose
		syntax.showVars()

void main(string[] arg)
	verbose = false
	string filename
	for a in arg
		if a == "--verbose"
			verbose = true
		else
			filename = a
	if filename.num > 0
		string source = FileRead(filename)
		eval(source)
