let KABA_LINK = "/usr/lib64/libsqlite3.so
	_sqlite3_open_v2:sqlite3_open_v2
	_sqlite3_close:sqlite3_close
	sqlite3_libversion_number:sqlite3_libversion_number
	_sqlite3_prepare:sqlite3_prepare
	_sqlite3_step:sqlite3_step
	_sqlite3_finalize:sqlite3_finalize
	_sqlite3_column_count:sqlite3_column_count
	_sqlite3_column_text:sqlite3_column_text
	_sqlite3_column_int:sqlite3_column_int
	_sqlite3_column_double:sqlite3_column_double
	_sqlite3_errmsg:sqlite3_errmsg
	_sqlite3_column_name:sqlite3_column_name
	_sqlite3_column_type:sqlite3_column_type
"

let _SQLITE_OPEN_READWRITE = 2
let _SQLITE_OPEN_CREATE = 4

func extern sqlite3_libversion_number() -> int
func extern _sqlite3_open_v2(fn: char*, db: void*, flags: int, zzz: void*) -> int
func extern _sqlite3_close(db: void*) -> int
func extern _sqlite3_finalize(r: void*) -> int
func extern _sqlite3_prepare(db: void*, sql: char*, len: int, res: void*, zzz: void*) -> int
func extern _sqlite3_column_count(r: void*) -> int
func extern _sqlite3_column_text(r: void*, c: int) -> char[0]*
func extern _sqlite3_column_int(r: void*, c: int) -> int
func extern _sqlite3_column_double(r: void*, c: int) -> float64
func extern _sqlite3_step(r: void*) -> int
func extern _sqlite3_errmsg(db: void*) -> char[0]*
func extern _sqlite3_column_name(r: void*, c: int) -> char[0]*
func extern _sqlite3_column_type(r: void*, c: int) -> int

func _cstr2str(cs: char[0]*) -> string
	var s: string
	for j in 0:10000
		if cs[j] == 0
			break
		s.add(cs[j])
	return s

class Database
	var db = nil
	func __delete__()
		_sqlite3_close(db)

	func error() -> string
		return _cstr2str(_sqlite3_errmsg(db))
		
	func query(sql: string) -> xfer[Query]
		var s = sql
		s.add(0)
		var q = new Query()
		if _sqlite3_prepare(db, &s[0], len(sql), &q.res, nil) != 0
			raise(new Exception("sql query failed: " + error()))
		return give(q)

	func run(sql: string)
		var q = query(sql)
		q.step()
	
	func load_doc(table: string, id: any) -> any
		var sql = "select * from {{table}} where id = {{id}}"
		print(sql)
		var q = query(sql)
		if !q.has_more()
			raise(new Exception("{{id}} not found in {{table}}"))
		var r = q.get_column()
		return r
	
	#any save_doc(string table, any id)
	#	var q = query("select * from " + table + " where id = " + str(id))
	#	if !q.has_more()
	#		raise(new Exception(str(id) + " not found in " + table))
	#	any r = q.get_column()
	#	del q
	#	return r

class Query as shared
	var res = nil
	var step_result: int
	var needs_step = true
	func __delete__()
		_sqlite3_finalize(res)

	func mut step()
		step_result = _sqlite3_step(res)
	
	func mut has_more() -> bool
		if needs_step
			step()
			needs_step = false
		return step_result == 100
	
	func mut get_column_text() -> string[]
		var r: string[]
		if !has_more()
			return r
		var n = _sqlite3_column_count(res)
		for i in 0:n
			r.add(_cstr2str(_sqlite3_column_text(res, i)))
		needs_step = true
		return r

	func mut get_column() -> any
		var r: any
		if !has_more()
			return r
		var n = _sqlite3_column_count(res)
		for i in 0:n
			var key = _cstr2str(_sqlite3_column_name(res, i))
			var t = _sqlite3_column_type(res, i)
			if t == 1 # int
				r[key] = _sqlite3_column_int(res, i)
			else if t == 2 # double
				r[key] = float(_sqlite3_column_double(res, i))
			else if t == 3 # text
				r[key] = _cstr2str(_sqlite3_column_text(res, i))
		needs_step = true
		return r


	func column_names() -> string[]
		var r: string[]
		var n = _sqlite3_column_count(res)
		for i in 0:n
			r.add(_cstr2str(_sqlite3_column_name(res, i)))
		return r
		

func sqlite_open(filename: string) -> xfer[Database]
	var f = filename
	f.add(0)
	var db = new Database()
	_sqlite3_open_v2(&f[0], &db.db, _SQLITE_OPEN_READWRITE, nil)
	if !db.db
		raise(new Exception("can't open database {{filename}}"))
	return give(db)

func sqlite_create(filename: string) -> xfer[Database]
	var f = filename
	f.add(0)
	var db = new Database()
	_sqlite3_open_v2(&f[0], &db.db, _SQLITE_OPEN_READWRITE + _SQLITE_OPEN_CREATE, nil)
	if !db.db
		raise(new Exception("can't create database {{filename}}"))
	return give(db)


func __main()
	var db = sqlite_create("test.sqlite3")
	db.run("create table michi (id text, a integer, b text)")
	db.run("insert into michi (id,a,b) values ('1001',13,'xxx')")
	db.run("insert into michi (id,a,b) values ('1002',14,'yyy')")
	db.run("insert into michi (id,a,b) values ('1003',15,'zzz')")

func main()
	var db = sqlite_open("test.sqlite3")
	if true
		var q = db.query("select * from michi")
#		var q = db.query("SELECT * FROM sqlite_master where type='table'")
#		print(q.column_names())
		while q.has_more()
			print(q.get_column())
	#print(db.load_doc("michi", "1002"))

