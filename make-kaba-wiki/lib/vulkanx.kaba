use vulkan
use time
use image


func _v1(p: vector, n: vector, u: float, v: float) -> Vertex
	Vertex r
	r.pos = p
	r.normal = n
	r.u = u
	r.v = v
	return r


func create_quad(r: rect) -> VertexBuffer*
	var vb = new VertexBuffer()
	Vertex[] vertices
	vertices.add(_v1(vector(r.x1,r.y1,0), vector.EZ, 0, 0))
	vertices.add(_v1(vector(r.x2,r.y1,0), vector.EZ, 1, 0))
	vertices.add(_v1(vector(r.x1,r.y2,0), vector.EZ, 0, 1))
	vertices.add(_v1(vector(r.x2,r.y2,0), vector.EZ, 1, 1))
	vb.build(vertices, [0,1,3, 0,3,2])
	return vb


class Renderer
	int width, height
	Fence* in_flight_fence
	Semaphore* image_available_semaphore, render_finished_semaphore
	CommandBuffer* cb
	DescriptorPool* pool

	func __init__()
		width = 0
		height = 0
		pool = nil
	
		in_flight_fence = new Fence()
		image_available_semaphore = new Semaphore()
		render_finished_semaphore = new Semaphore()
		cb = new CommandBuffer()
	
	func virtual __delete__()
		del in_flight_fence
		del image_available_semaphore
		del render_finished_semaphore
		if pool
			del pool
	
	func virtual default_render_pass() -> RenderPass*
		return nil
		
	func virtual current_frame_buffer() -> FrameBuffer*
		return nil

	func virtual start_frame() -> bool
		return false

	func virtual end_frame()
		pass
	
	func const area() -> rect
		return rect(0, width, 0, height)


class WindowRenderer extends Renderer
	void* window
	SwapChain* swap_chain
	RenderPass* _default_render_pass
	DepthBuffer* depth_buffer
	FrameBuffer*[] frame_buffers
	int image_index
	bool framebuffer_resized
	
	func __init__(_window: void*)
		window = _window
		framebuffer_resized = false
		pool = new DescriptorPool("buffer:1024,sampler:1024", 1024)

		_create_swap_chain_and_stuff()

		#main_renderer = this
	#glfwSetFramebufferSizeCallback(window, framebuffer_resize_callback);

	func override __delete__()
		_delete_swap_chain_and_stuff()

	func _create_swap_chain_and_stuff()
		swap_chain = new SwapChain(window)
		depth_buffer = swap_chain.create_depth_buffer()
		_default_render_pass = swap_chain.create_render_pass(depth_buffer)
		frame_buffers = swap_chain.create_frame_buffers(_default_render_pass, depth_buffer)
		width = swap_chain.width
		height = swap_chain.height
	
	func _delete_swap_chain_and_stuff()
		for fb in frame_buffers
			del fb
		del _default_render_pass
		del depth_buffer
		del swap_chain

#void WindowRenderer::framebuffer_resize_callback(GLFWwindow* window, int width, int height) {
#	main_renderer->on_resize(width, height);

#void WindowRenderer::on_resize(int w, int h) {
#	width = w;
#	height = h;
#	framebuffer_resized = true;

	func rebuild_default_stuff()
		print("recreate swap chain")

		wait_device_idle()

		_delete_swap_chain_and_stuff()
		_create_swap_chain_and_stuff()
	
	func override default_render_pass() -> RenderPass*
		return _default_render_pass

	func override current_frame_buffer() -> FrameBuffer*
		return frame_buffers[image_index]

	func override start_frame() -> bool
		in_flight_fence.wait()

		if !swap_chain.aquire_image(&image_index, image_available_semaphore)
			rebuild_default_stuff()
			return false
		return true

	func override end_frame()
		queue_submit_command_buffer(cb, [image_available_semaphore], [render_finished_semaphore], in_flight_fence)

		if !swap_chain.present(image_index, [render_finished_semaphore]) or framebuffer_resized
			framebuffer_resized = false
			rebuild_default_stuff()
		wait_device_idle()














class TextureRenderer extends Renderer
	Texture* tex
	DepthBuffer* depth_buffer
	FrameBuffer* frame_buffer
	RenderPass* _default_render_pass


	func __init__(t: Texture*)
		tex = t
		width = tex.width
		height = tex.height

		#vulkan::next_compare_op = VK_COMPARE_OP_LESS;
		depth_buffer = new DepthBuffer(width, height, "d:f32", true)
		#vulkan::next_compare_op = VK_COMPARE_OP_ALWAYS;

		_default_render_pass = new RenderPass([tex.format, depth_buffer.format], "clear")
		frame_buffer = new FrameBuffer(width, height, _default_render_pass, [tex.view, depth_buffer.view])


	func override __delete__()
		del _default_render_pass
		del depth_buffer
		del frame_buffer
		del tex

	func override start_frame() -> bool
		cb.begin()
		return true

	func override end_frame()
		#cb->barrier([tex, depth_buffer], 0);
		cb.barrier([depth_buffer], 0)
		cb.end()

		queue_submit_command_buffer(cb, [], [], in_flight_fence)
		in_flight_fence.wait()
		wait_device_idle()


	func override current_frame_buffer() -> FrameBuffer*
		return frame_buffer






class UBO
	matrix m,v,p

class StatLayer
	Texture* tex
	UniformBuffer* ubo
	DescriptorSet* dset
	Timer* timer
	Image* im
	VertexBuffer* vb
	Pipeline* pipeline
	int frames
	float _time
	
	func __init__(shader: Shader*, rp: RenderPass*, subpass: int, pool: DescriptorPool*)
		timer = new Timer()
		_time = 0
		frames = 0
		im = new Image(256, 64, color(0,0,0,0))
		tex = new Texture()
		tex.override(im)
		ubo = new UniformBuffer(64*3)
		UBO u
		u.p = matrix.ID
		u.v = matrix.ID
		u.m = matrix.ID
		ubo.update(&u)
		dset = pool.create_set("buffer,sampler")
		dset.set_buffer(0, ubo)
		dset.set_texture(1, tex)
		dset.update()
		vb = create_quad(rect(-1,-0.3,-1,-0.8))
		pipeline = new Pipeline(shader, rp, subpass, 1)
		pipeline.set_blend(6,7)
		pipeline.set_z(false, false)
		pipeline.rebuild()
	func __delete__()
		del timer
		del ubo
		del tex
		del dset
		del vb
		del pipeline
	func tick()
		float dt = timer.get()
		_time += dt
		frames ++
		if _time < 0.1
			return
		
		im.create(256, 64, color(0,1,1,1))
		var pp = im.start_draw()
		pp.set_color(color.WHITE)
		pp.set_font_size(20)
		pp.draw_str(5,5, "{{frames/_time|1}}")
		del pp
		tex.override(im)
		dset.set_texture(1, tex)
		dset.update()
		frames = 0
		_time = 0
	func draw(out cb: CommandBuffer)
		cb.bind_pipeline(pipeline)
		cb.bind_descriptor_set(0, dset)
		cb.draw(vb)
		
		
		
