use "localdb.kaba"
use "config.kaba"


// mix db files with "real" files
class DBLister
	string[] paths
	LocalFile*[] files
	LocalFile[] fake_files
	LocalFile ff
	
	bool is_ignored(string path)
		for i in conf.ignore
			if path.match(i)
				return true
		return false

	void find_paths(string _dir)
		string dir = dir_canonical(_dir)
		DirEntry[] list = DirSearch(dir, "*", true)
		for e in list
			if e.is_dir
				if e.name.head(1) != "."
					find_paths(dir + e.name)
			else
				string path = (dir + e.name)
				if !is_ignored(path)
					paths.add(path)
	void sort_files()
		for i in 0:files.num
			for j in i+1:files.num
				if files[i].path > files[j].path
					LocalFile* f = files[i]
					files[i] = files[j]
					files[j] = f
	
	LocalFile*[] find(string dir)
		files.clear()
		fake_files.clear()
		paths.clear()
		
		if !FileIsDirectory(dir)
			LocalFile* f = db.find_by_path(dir)
			if f
				files.add(f)
			else if FileExists(dir)
				ff.path = dir
				files.add(&ff)
			return files

		files = db.get_in_dir(dir)
		
		find_paths(dir)
		for p in paths
			if !db.find_by_path(p)
				LocalFile f
				f.path = p
				fake_files.add(f)
		for f in fake_files
			files.add(&f)
		sort_files()
		return files

DBLister lister









// "add"
void file_add(LocalFile* f)
	if f.in_db()

		// suddenly appearing?!?
		if f.pure_remote()
			if FileExists(f.path)
				f.unset(NONLOCAL)
				print("NON-NONLOCAL " + f.path)
				return
		
		// lost?
		if !FileExists(f.path)
			if !f.pure_remote()
				f.set(NONLOCAL)
				print("LOST  " + f.path)
			return
		
		// time
		File* ff = FileOpen(f.path)
		int mtime = ff.getMDate().time
		if mtime == f.mtime
			if conf.verbose
				print("=  " + f.path)
		else
			// changed?
			string hash = FileHash(f.path, "md5")
			if hash == f.hash
				print("TOUCHED  " + f.path)
				// ok
				f.mtime = mtime
			else
				print("EDITED  " + f.path)
				f.set(CHANGED_FILE)
				f.hash = hash
				f.mtime = mtime
				f.size = ff.getSize()
				if conf.verbose
					f.show_info("      ")
		delete ff
	else
		// new file
		
		string hash = FileHash(f.path, "md5")
		LocalFile* ff = db.find_by_hash(hash)
		if ff
			// hash already in db?
			if FileExists(ff.path)
				print("ERROR: duplicate " + f.path + " <-> " + ff.path)
				return
			print("MOVED  " + ff.path + " > " + f.path)
			ff.path = f.path
			db.dirty = true
		else
			// new
			print("ADD  " + f.path)
			f.name = f.path.basename()
			string ext = f.path.extension()
			if ext.num > 0
				f.name = f.name.head(f.name.num - ext.num - 1)
			//print(ext)
			//print(l.name)
			f.hash = hash
			File* fff = FileOpen(f.path)
			f.mtime = fff.getMDate().time
			f.size = fff.getSize()
			delete fff
			if conf.verbose
				f.show_info("      ")
			db.files.add(*f)










// check for local changes
void action_add(string path)
	set_working_dir(path)
	
	LocalFile*[] files = lister.find(path)
	for f in files
		file_add(f)
		
		/*LocalFile[] dbfiles = get_in_dir(e.dir, true)
		LocalFile[] todrop
		for ff in dbfiles
			if ff.is("nonlocal")
				print("+R " + ff.path)
				continue
					
			if FileExists(ff.path)
				nil
				// already checked...
			else
				print("-  " + ff.path)
				ff.set("deleted")
				
				if conf.drop_deleted
					todrop.add(ff)
		
		for ff in todrop
			drop(ff)*/
			
	db.save()

void action_rm(string path)
	set_working_dir(path)
		
	LocalFile*[] files = lister.find(path)
	for f in files
		f.drop_me = true
	db.save()
	
void action_mv(string source, string dest)
	LocalFile* f = db.find_by_path(source)
	if !f
		print("ERROR: not in db")
		return
	if FileExists(dest) or db.find_by_path(dest)
		print("ERROR: dest not available")
		return
	f.path = dest
	db.save()
		
	if FileExists(source)
		make_all_dirs(dest)
		FileRename(source, dest)


void action_cleanup_structure(string _dir)
	set_working_dir(_dir)
	string dir = dir_canonical(_dir)
	LocalFile*[] files = db.get_in_dir(dir)
	for f in files
		ConfigDir* e = conf.get_cfg(f.path)
		if !e
			continue
		string new_path = f.apply_structure(*e)
		if f.path == new_path
			continue
		print(f.path + " -> " + new_path)
		make_all_dirs(new_path)
		_exec_("mv \"" + bash_escape(f.path) + "\" \"" + bash_escape(new_path) + "\"")
		f.path = new_path
		db.save()

void action_info(string path)
	LocalFile* f = db.find_by_path(path)
	if !f
		print("ERROR: not in db")
		return
	f.show()
	f.show_info("      ")

void action_list(string path)
	set_working_dir(path)
	conf.show_pure_local = true
	
	LocalFile*[] files = lister.find(path)
	for f in files
		f.show()
		if conf.verbose
			f.show_info("      ")


void action_find(string filter)
	LocalFile*[] files = db.find_by_tags(filter)
	for f in files
		f.show()
	
void action_tag_add(string path, string key, string value)
	LocalFile* f = db.find_by_path(path)
	if !f
		print("ERROR: not in db")
		return
	f.tag_add(key, value)
	db.dirty = true

void action_tag_set(string path, string key, string value)
	LocalFile* f = db.find_by_path(path)
	if !f
		print("ERROR: not in db")
		return
	f.tag_set(key, value)
	db.dirty = true

void action_tag_rm(string path, string key, string value)
	LocalFile* f = db.find_by_path(path)
	if !f
		print("ERROR: not in db")
		return
	f.tag_rm(key, value)
	db.dirty = true
