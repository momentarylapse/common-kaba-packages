use os
use localdb
use config
use remote
use tag


# mix db files with "real" files
class DBLister
	string[] paths
	LocalFile[] fake_files
	
	bool is_ignored(string path)
		for i in conf.ignore
			if path.match(i)
				return true
		return false

	void find_paths(string _dir, bool recursive)
		string dir = dir_canonical(_dir)
		let list = Filesystem.search(dir, "*", true)
		for e in list
			if e.is_dir
				if e.name.head(1) != "." and recursive
					find_paths(dir + e.name, recursive)
			else
				string path = (dir + e.name)
				if !is_ignored(path)
					paths.add(path)
	
	LocalFile*[] find(string dir)
		if Filesystem.is_directory(dir)
			return find_dir(dir)
		return find_file(dir)
		
		
	LocalFile*[] find_file(string path)
		LocalFile*[] files
		fake_files.clear()
		paths.clear()
		
		try
			# in DB?
			return [db.find_by_path(path)]
		except
			if Filesystem.exists(path)
				LocalFile ff
				ff.path = path
				fake_files.add(ff)
				return [&fake_files[0]]
			else
				print("ERROR: can't find '{{path}}'")
		return files
		
	LocalFile*[] find_dir(string dir)
		LocalFile*[] files
		fake_files.clear()
		paths.clear()

		files = db.get_in_dir(dir, conf.recursive)
		
		find_paths(dir, conf.recursive)
		for p in paths
			try
				db.find_by_path(p)
			except
				LocalFile f
				f.path = p
				fake_files.add(f)
		for f in fake_files
			files.add(&f)
		return sorted(files, "path")

DBLister lister









# "add"
void file_add(out LocalFile f)
	if f.in_db()

		# suddenly appearing?!?
		if f.pure_remote()
			if Filesystem.exists(f.path)
				f.unset(NONLOCAL)
				if conf.verbosity >= 1
					print("NON-NONLOCAL {{rel_path(f.path)}}")
				return
		
		# lost?
		if !Filesystem.exists(f.path)
			if !f.pure_remote()
				f.set(NONLOCAL)
				if conf.verbosity >= 1
					print("LOST  {{rel_path(f.path)}}")
			return
		
		# time
		File* ff = Filesystem.open(f.path)
		int mtime = ff.get_date().time
		if mtime == f.mtime
			if conf.verbosity >= 2
				print("=  {{rel_path(f.path)}}")
		else
			# changed?
			try
				string hash = Filesystem.hash(f.path, "md5")
				if hash == f.hash
					if conf.verbosity >= 1
						print("TOUCHED  {{rel_path(f.path)}}")
					# ok
					f.mtime = mtime
				else
					if conf.verbosity >= 1
						print("EDITED  {{rel_path(f.path)}}")
					f.set(CHANGED_FILE)
					f.hash = hash
					f.mtime = mtime
					f.size = ff.get_size()
					if conf.verbosity >= 2 or conf.show_meta
						f.show_info("      ")
			except Exception as e
				print(e.message())
				return
		del ff
	else
		# new file
		string hash
		try
			hash = Filesystem.hash(f.path, "md5")
		except Exception as e
			print(e.message())
			return
		try
			LocalFile* ff = db.by_hash(hash)
			# hash already in db?
			if Filesystem.exists(ff.path)
				if conf.verbosity >= 1
					print("DUPLICATE  {{rel_path(f.path)}} <-> {{rel_path(ff.path)}}")
				file_add_new(f, hash)
			else
				file_move(ff, f.path)
		except
			# new
			file_add_new(f, hash)


void file_add_new(out LocalFile f, string hash)
	print("ADD  {{rel_path(f.path)}}")
	f.name = f.path.basename()
	string ext = f.path.extension()
	if len(ext) > 0
		f.name = f.name.head(len(f.name) - len(ext) - 1)
	#print(ext)
	#print(f.name)
	f.hash = hash
	File* fff = Filesystem.open(f.path)
	f.mtime = fff.get_date().time
	f.size = fff.get_size()
	del fff
	auto_tag(f)
	if conf.show_meta or conf.verbosity >= 2
		f.show_info("      ")
	db.files.add(f)


void file_move(out LocalFile f, string new_path)
	if conf.verbosity >= 1
		print("MOVED  {{rel_path(f.path)}} > {{rel_path(new_path)}}")
	f.path = new_path
	db.dirty = true





# check for local changes
void _action_add(string path)
	set_working_dir(path)
	let files = lister.find(path)
	for f in files
		file_add(f)
			
	db.save()

void action_add(string[] arg)
	if len(arg) == 0
		_action_add(absolute_path("./"))
	for a in arg
		_action_add(absolute_path(a))


void _action_unadd(string path)
	set_working_dir(path)
		
	let files = lister.find(path)
	for f in files
		print("DROP  {{f.path}}")
		f.drop_me = true
		db.save()

void action_unadd(string[] arg)
	if len(arg) == 0
		_action_unadd(absolute_path("./"))
	for a in arg
		_action_unadd(absolute_path(a))


void _action_rm(string path)
	set_working_dir(path)
		
	let files = lister.find(path)
	for f in files
		if !f.pure_remote()
			try
				Filesystem.delete(f.path)
			except Exception as e
				print("ERROR: {{e}}")
		f.drop_me = true
		db.save()

void action_rm(string[] arg)
	for a in arg
		_action_rm(absolute_path(a))

	
void _action_mv(string source, string _dest)
	try
		string dest = _dest
		let f = db.find_by_path(source)
		if Filesystem.is_directory(dest)
			dest = dir_canonical(dest) + source.basename()
		if Filesystem.exists(dest) or db.has_path(dest)
			raise(new Exception("target already exists"))
		print("MOVE  {{rel_path(source)}} -> {{rel_path(dest)}}")
		f.path = dest
		db.save()
		
		if Filesystem.exists(source)
			make_all_dirs(dest)
			Filesystem.rename(source, dest)
	except Exception as e
		error_out(e)

void action_mv(string[] arg)
	for i in 0:arg.num-1
		_action_mv(absolute_path(arg[i]), absolute_path(arg[len(arg)-1]))


void structure_file(out LocalFile f, string structure, string root)
	string new_path = f.apply_structure(root, structure)
	if f.path == new_path
		return
	print("MOVE  {{rel_path(f.path)}} -> {{rel_path(new_path)}}")
	make_all_dirs(new_path)
	try
		if !f.pure_remote()
			Filesystem.rename(f.path, new_path)
		f.path = new_path
		db.save()
	except FileError as e
		error_out(e)

void action_structure_apply(string _dir, string structure)
	set_working_dir(_dir)
	string dir = dir_canonical(_dir)
	let files = db.get_in_dir(dir, conf.recursive)
	for f in files
		structure_file(f, structure, dir)


void action_structure_auto(string _dir)
	set_working_dir(_dir)
	string dir = dir_canonical(_dir)
	let files = db.get_in_dir(dir, conf.recursive)
	for f in files
		ConfigDir* e = conf.get_cfg(f.path)
		if !e
			continue
		structure_file(f, e.structure, e.dir)


void show_files(LocalFile*[] files)
	for f in files
		if f.perfectly_fine() and !conf.show_perfectly_fine
			continue
		if !f.in_db() and !conf.show_not_in_db
			continue
		f.show()
		if conf.show_meta or conf.verbosity >= 2
			f.show_info("      ")

void _action_list(string path)
	set_working_dir(path)
	conf.show_pure_local = true
	show_files(lister.find(path))

void action_list(string[] arg)
	if len(arg) == 0
		_action_list(absolute_path("./"))
	for a in arg
		_action_list(absolute_path(a))

void _action_status(string path)
	set_working_dir(path)
	conf.show_pure_local = true
	conf.show_perfectly_fine = false
	show_files(lister.find(path))

void action_status(string[] arg)
	if len(arg) == 0
		_action_status(absolute_path("./"))
	for a in arg
		_action_status(absolute_path(a))

void action_find(string[] arg)
	for filter in arg
		show_files(db.find_by_tags(filter))

	
void _action_tag_add(string path, string tag)
	set_working_dir(path)
	let files = lister.find(path)
	let t = str2tag(tag)
	for f in files
		f.tag_add(t)

void action_tag_add(string[] arg)
	if len(arg) < 2
		_action_tag_add(absolute_path("./"), arg[0])
	for a in arg[1:]
		_action_tag_add(absolute_path(a), arg[0])


void _action_tag_set(string path, string tag)
	set_working_dir(path)
	let files = lister.find(path)
	let t = str2tag(tag)
	for f in files
		f.tag_set(t)

void action_tag_set(string[] arg)
	if len(arg) < 2
		_action_tag_set(absolute_path("./"), arg[0])
	for a in arg[1:]
		_action_tag_set(absolute_path(a), arg[0])


void _action_tag_rm(string path, string tag)
	set_working_dir(path)
	let files = lister.find(path)
	let t = str2tag(tag)
	for f in files
		f.tag_rm(t)

void action_tag_rm(string[] arg)
	if len(arg) < 2
		_action_tag_rm(absolute_path("./"), arg[0])
	for a in arg[1:]
		_action_tag_rm(absolute_path(a), arg[0])


void _action_tag_get(string path, string key)
	set_working_dir(path)
	let files = lister.find(path)
	for f in files
		f.show()
		for t in f.tags
			if t.key == key
				print("      {{t}}")
		if key == "name"
			print("      name={{f.name}}")
		else if key == "hash"
			print("      hash={{f.hash}}")
		else if key == "id" and len(f.id) > 0
			print("      id={{f.id}}")

void action_tag_get(string[] arg)
	if len(arg) < 2
		_action_tag_get(absolute_path("./"), arg[0])
	for a in arg[1:]
		_action_tag_get(absolute_path(a), arg[0])


void _action_pull(string path)
	set_working_dir(path)
	
	let files = lister.find(path)
	LocalFile*[] need_meta
	for f in files
		if f.pure_remote() or f.is(CHANGED_FILE)
			remote_download(f)
		if f.is(CHANGED_META)
			need_meta.add(f)

	if len(need_meta) > 0
		if conf.verbosity >= 2
			print("downloading meta data")
		remote_download_meta(need_meta)

void action_pull(string[] arg)
	if len(arg) == 0
		_action_pull(absolute_path("./"))
	for a in arg
		_action_pull(absolute_path(a))


void _action_push(string path)
	set_working_dir(path)
	
	let files = lister.find(path)
	for f in files
		if !f.in_db()
			continue
		if f.pure_local() #or f.is(CHANGED_FILE)
			remote_upload(f)
		if f.is(CHANGED_META)
			print("UPLOADING META  {{rel_path(f.path)}}")
			remote_upload_meta(f)

void action_push(string[] arg)
	if len(arg) == 0
		_action_push(absolute_path("./"))
	for a in arg
		_action_push(absolute_path(a))


void _action_get(string id)
	try
		let ff = db.find_by_id(id)
		if ff.pure_remote()
			remote_download(ff)
		else
			print("id={{id}} already local: {{ff.path}}")
	except
		let files = remote_find_by_id([id], "")
		if len(files) > 0
			LocalFile f = files[0]
			f.path = Filesystem.current_directory() + "{{f.id}}-{{f.name}}.{{f.path.extension()}}"
			db.files.add(f)
			let ff = db.find_by_id(id)
			remote_download(ff)
		else
			print("not found: id={{id}}")
			return

void action_get(string[] arg)
	for a in arg
		_action_get(a)


void show_rfile_list(RemoteFile[] rfiles)
	for f in rfiles
		f.show()
		if conf.show_meta
			f.show_info("      ")


void action_remote_find(string[] arg)
	for filter in arg
		show_rfile_list(remote_find(filter, conf.default_quality))

#void action_remote_find_hash(string[] hashes)
#	show_rfile_list(remote_find_by_hash(hashes))

#void action_remote_find_id(string[] ids)
#	show_rfile_list(remote_find_by_id(ids, ""))

void action_remote_add(string[] arg) # filter, dir
	remote_sync_by_filter(arg[0], conf.default_quality, conf.default_structure, absolute_path(arg[1]))

void _action_dsync(string dir)
	set_working_dir(dir)
	let e = conf.get_cfg(dir)
	if e
		for s in e.syncs
			remote_sync_by_filter(s.filter, s.quality(), "", dir)
	let files = db.get_in_dir(dir, conf.recursive)
	print("syncing entangled files")
	remote_sync_by_id(files)
	print("matching pure local files by hash")
	remote_sync_pure_locals_by_hash(files)

void action_dsync(string[] arg)
	if len(arg) == 0
		_action_dsync(absolute_path("./"))
	for a in arg
		_action_dsync(absolute_path(a))

void _action_sync(string path)
	set_working_dir(path)
	let files = lister.find(path)
	remote_sync_pure_locals_by_hash(files)
	remote_sync_by_id(files)

void action_sync(string[] arg)
	if len(arg) == 0
		_action_sync(absolute_path("./"))
	for a in arg
		_action_sync(absolute_path(a))

	
void _action_tag_auto(string path)
	set_working_dir(path)
	let files = lister.find(path)
	for f in files
		auto_tag(f)

void action_tag_auto(string[] arg)
	if len(arg) == 0
		_action_tag_auto(absolute_path("./"))
	for a in arg
		_action_tag_auto(absolute_path(a))


void _action_tag_diff(string path)
	set_working_dir(path)
	let files = lister.find(path)
	let rfiles = remote_get_meta(files)
	for rf in rfiles
		for lf in files
			if lf.id == rf.id
				if !tags_equal(lf.tags, rf.tags)
					lf.show()
					tags_diff(lf.tags, rf.tags)

void action_tag_diff(string[] arg)
	if len(arg) == 0
		_action_tag_diff(absolute_path("./"))
	for a in arg
		_action_tag_diff(absolute_path(a))
