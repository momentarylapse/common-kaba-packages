use "localdb.kaba"
use "config.kaba"
use "remote.kaba"
use "tag.kaba"


// mix db files with "real" files
class DBLister
	string[] paths
	LocalFile[] fake_files
	
	bool is_ignored(string path)
		for i in conf.ignore
			if path.match(i)
				return true
		return false

	void find_paths(string _dir, bool recursive)
		string dir = dir_canonical(_dir)
		DirEntry[] list = DirSearch(dir, "*", true)
		for e in list
			if e.is_dir
				if e.name.head(1) != "." and recursive
					find_paths(dir + e.name, recursive)
			else
				string path = (dir + e.name)
				if !is_ignored(path)
					paths.add(path)
	
	LocalFile*[] find(string dir)
		if FileIsDirectory(dir)
			return find_dir(dir)
		return find_file(dir)
		
		
	LocalFile*[] find_file(string path)
		LocalFile*[] files
		fake_files.clear()
		paths.clear()
		
		try
			// in DB?
			return [db.find_by_path(path)]
		except
			if FileExists(path)
				LocalFile ff
				ff.path = path
				fake_files.add(ff)
				return [&fake_files[0]]
			else
				print("ERROR: can't find '" + path + "'")
		return files
		
	LocalFile*[] find_dir(string dir)
		LocalFile*[] files
		fake_files.clear()
		paths.clear()

		files = db.get_in_dir(dir, conf.recursive)
		
		find_paths(dir, conf.recursive)
		for p in paths
			try
				db.find_by_path(p)
			except
				LocalFile f
				f.path = p
				fake_files.add(f)
		for f in fake_files
			files.add(&f)
		sort_list(&files, type(files), "path")
		return files

DBLister lister









// "add"
void file_add(LocalFile* f)
	if f.in_db()

		// suddenly appearing?!?
		if f.pure_remote()
			if FileExists(f.path)
				f.unset(NONLOCAL)
				print("NON-NONLOCAL " + rel_path(f.path))
				return
		
		// lost?
		if !FileExists(f.path)
			if !f.pure_remote()
				f.set(NONLOCAL)
				print("LOST  " + rel_path(f.path))
			return
		
		// time
		File* ff = FileOpen(f.path)
		int mtime = ff.get_date().time
		if mtime == f.mtime
			if conf.verbose
				print("=  " + rel_path(f.path))
		else
			// changed?
			try
				string hash = FileHash(f.path, "md5")
				if hash == f.hash
					print("TOUCHED  " + rel_path(f.path))
					// ok
					f.mtime = mtime
				else
					print("EDITED  " + rel_path(f.path))
					f.set(CHANGED_FILE)
					f.hash = hash
					f.mtime = mtime
					f.size = ff.get_size()
					if conf.verbose or conf.show_meta
						f.show_info("      ")
			except Exception as e
				print(e.message())
				return
		delete ff
	else
		// new file
		string hash
		try
			hash = FileHash(f.path, "md5")
		except Exception as e
			print(e.message())
			return
		try
			LocalFile* ff = db.by_hash(hash)
			// hash already in db?
			if FileExists(ff.path)
				print("DUPLICATE  " + rel_path(f.path) + " <-> " + rel_path(ff.path))
				file_add_new(f, hash)
			else
				file_move(ff, f.path)
		except
			// new
			file_add_new(f, hash)


void file_add_new(LocalFile* f, string hash)
	print("ADD  " + rel_path(f.path))
	f.name = f.path.basename()
	string ext = f.path.extension()
	if ext.num > 0
		f.name = f.name.head(f.name.num - ext.num - 1)
	//print(ext)
	//print(l.name)
	f.hash = hash
	File* fff = FileOpen(f.path)
	f.mtime = fff.get_date().time
	f.size = fff.get_size()
	delete fff
	auto_tag(f)
	if conf.show_meta or conf.verbose
		f.show_info("      ")
	db.files.add(*f)


void file_move(LocalFile *f, string new_path)
	print("MOVED  " + rel_path(f.path) + " > " + rel_path(new_path))
	f.path = new_path
	db.dirty = true





// check for local changes
void action_add(string path)
	set_working_dir(path)
	let files = lister.find(path)
	for f in files
		file_add(f)
			
	db.save()

void action_rm(string path)
	set_working_dir(path)
		
	let files = lister.find(path)
	for f in files
		f.drop_me = true
	db.save()
	
void action_mv(string source, string _dest)
	try
		string dest = _dest
		let f = db.find_by_path(source)
		if FileIsDirectory(dest)
			dest = dir_canonical(dest) + source.basename()
		if FileExists(dest) or db.has_path(dest)
			raise(new Exception("target already exists"))
		print("MOVE  " + rel_path(source) + " -> " + rel_path(dest))
		f.path = dest
		db.save()
		
		if FileExists(source)
			make_all_dirs(dest)
			FileRename(source, dest)
	except Exception as e
		error_out(e)


void structure_file(LocalFile* f, string structure, string root)
	string new_path = f.apply_structure(root, structure)
	if f.path == new_path
		return
	print("MOVE  " + rel_path(f.path) + " -> " + rel_path(new_path))
	make_all_dirs(new_path)
	try
		if !f.pure_remote()
			FileRename(f.path, new_path)
		f.path = new_path
		db.save()
	except FileError as e
		error_out(e)

void action_structure_apply(string _dir, string structure)
	set_working_dir(_dir)
	string dir = dir_canonical(_dir)
	let files = db.get_in_dir(dir, conf.recursive)
	for f in files
		structure_file(f, structure, dir)


void action_structure_auto(string _dir)
	set_working_dir(_dir)
	string dir = dir_canonical(_dir)
	let files = db.get_in_dir(dir, conf.recursive)
	for f in files
		ConfigDir* e = conf.get_cfg(f.path)
		if !e
			continue
		structure_file(f, e.structure, e.dir)

void action_info(string path)
	try
		let f = db.find_by_path(path)
		f.show()
		f.show_info("      ")
	except Exception as e
		error_out(e)

void show_files(LocalFile*[] files)
	for f in files
		if f.perfectly_fine() and !conf.show_perfectly_fine
			continue
		f.show()
		if conf.show_meta or conf.verbose
			f.show_info("      ")

void action_list(string path)
	set_working_dir(path)
	conf.show_pure_local = true
	show_files(lister.find(path))

void action_status(string path)
	set_working_dir(path)
	conf.show_pure_local = true
	conf.show_perfectly_fine = false
	show_files(lister.find(path))


void action_find(string filter)
	show_files(db.find_by_tags(filter))
	
void action_tag_add(string path, string tag)
	set_working_dir(path)
	let files = lister.find(path)
	let t = str2tag(tag)
	for f in files
		f.tag_add(t)

void action_tag_set(string path, string tag)
	set_working_dir(path)
	let files = lister.find(path)
	let t = str2tag(tag)
	for f in files
		f.tag_set(t)

void action_tag_rm(string path, string tag)
	set_working_dir(path)
	let files = lister.find(path)
	let t = str2tag(tag)
	for f in files
		f.tag_rm(t)

void action_tag_get(string path, string key)
	set_working_dir(path)
	let files = lister.find(path)
	for f in files
		f.show()
		for t in f.tags
			if t.key == key
				print("      " + str(t))



void action_pull(string path)
	set_working_dir(path)
	
	let files = lister.find(path)
	LocalFile*[] need_meta
	for f in files
		if f.pure_remote() or f.is(CHANGED_FILE)
			remote_download(f)
		if f.is(CHANGED_META)
			need_meta.add(f)

	if need_meta.num > 0
		if conf.verbose
			print("downloading meta data")
		remote_download_meta(need_meta)


void action_push(string path)
	set_working_dir(path)
	
	let files = lister.find(path)
	for f in files
		if f.pure_local() //or f.is(CHANGED_FILE)
			print("UPLOADING " + rel_path(f.path))
			remote_upload(f)
		if f.is(CHANGED_META)
			print("UPLOADING META " + rel_path(f.path))
			remote_upload_meta(f)


void action_get(string id)
	try
		let ff = db.find_by_id(id)
		if ff.pure_remote()
			remote_download(ff)
		else
			print("id=" + id + " already local: " + ff.path)
	except
		let files = remote_find_by_id([id], "")
		if len(files) > 0
			LocalFile f = files[0]
			f.path = GetCurDir() + f.id + "-" + f.name + "." + f.path.extension()
			db.files.add(f)
			let ff = db.find_by_id(id)
			remote_download(ff)
		else
			print("not found: id=" + id)
			return
		

void show_rfile_list(RemoteFile[] rfiles)
	for f in rfiles
		f.show()
		if conf.show_meta
			f.show_info("      ")


void action_remote_find(string filter)
	show_rfile_list(remote_find(filter, conf.default_quality))

void action_remote_find_hash(string[] hashes)
	show_rfile_list(remote_find_by_hash(hashes))

void action_remote_find_id(string[] ids)
	show_rfile_list(remote_find_by_id(ids, ""))

void action_remote_add(string filter, string dir)
	remote_sync_by_filter(filter, conf.default_quality, conf.default_structure, dir)

void action_dsync(string dir)
	set_working_dir(dir)
	let e = conf.get_cfg(dir)
	if e
		for s in e.syncs
			remote_sync_by_filter(s.filter, s.quality(), "", dir)
	let files = db.get_in_dir(dir, conf.recursive)
	print("syncing entangled files")
	remote_sync_by_id(files)
	print("matching pure local files by hash")
	remote_sync_pure_locals_by_hash(files)

void action_sync(string path)
	set_working_dir(path)
	let files = lister.find(path)
	remote_sync_pure_locals_by_hash(files)
	remote_sync_by_id(files)
	
void action_tag_auto(string path)
	set_working_dir(path)
	let files = lister.find(path)
	for f in files
		auto_tag(f)
	
void action_tag_diff(string path)
	set_working_dir(path)
	let files = lister.find(path)
	let rfiles = remote_get_meta(files)
	for rf in rfiles
		for lf in files
			if lf.id == rf.id
				if !tags_equal(lf.tags, rf.tags)
					lf.show()
					tags_diff(lf.tags, rf.tags)
	
