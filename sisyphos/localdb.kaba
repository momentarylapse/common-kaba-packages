use os
use hui
use config
use tag

const NONLOCAL = "nonlocal"
const CHANGED_FILE = "changed"
const CHANGED_META = "changed-meta"

func str_format(s: string, fmt: string) -> string
	var r = s
	if len(fmt) >= 2 and fmt[:1] == "0"
		var n = int(fmt)
		while len(r) < n
			r = "0" + r
	if len(fmt) >= 2 and fmt[:1] == " "
		var n = int(fmt)
		while len(r) < n
			r = " " + r
	return r

func nice_size(size: int) -> string
	if size > 1000000000
		return "{{size / 1000000000.0|.1}}G"
	if size > 10000000
		return "{{size / 1000000}}M"
	if size > 1000000
		return "{{size / 1000000.0|.1}}M"
	if size > 10000
		return "{{size / 1000}}K"
	if size > 1000
		return "{{size / 1000.0|.1}}K"
	return "{{size}}"


func file_status_color(f: LocalFile) -> string
	if !f.in_db()
		return "{{terminal.DARK_GRAY}}"
	if f.pure_local()
		return "{{terminal.GRAY}}"
	if f.pure_remote()
		return "{{terminal.ORANGE}}{{terminal.BOLD}}"
	if f.changed_file()
		return "{{terminal.RED}}{{terminal.BOLD}}"
	if f.changed_meta()
		return "{{terminal.YELLOW}}{{terminal.BOLD}}"
	return "{{terminal.BOLD}}"

func show_file(f: LocalFile)
	var s: string
	if conf.show_meta_small
		s = str_format(nice_size(f.size), " 6")
		if f.is("quality=medium")
			s += " m"
		else
			s += "  "
	print("{{file_status_color(f)}}{{f.status_str()}}{{s}} {{rel_path(f.path)}}{{terminal.END}}")

class LocalFile
	var drop_me = false

	# remote
	var id: string
	var name: string
	var remote_mtime: int
#	var remote_path: string
	# local
	var path: Path
	var hash: string # can be "" if not local
	var mtime: int
	var size: int
	var options: string[]
	var tags: Tag[]
	
	func is(option: string) -> bool
		for o in options
			if o == option
				return true
		return false
	func mut set(option: string)
		if is(option)
			return
		options.add(option)
		db.dirty = true
	func mut unset(option: string)
		for i=>o in options
			if o == option
				options.remove(i)
				db.dirty = true
				return
	func pure_remote() -> bool
		return is(NONLOCAL)
	func pure_local() -> bool
		return len(id) == 0
	func perfectly_fine() -> bool
		if pure_remote() or pure_local()
			return false
		if changed_meta() or changed_file()
			return false
		return true
	func in_db() -> bool
		return len(hash) > 0
	func changed_file() -> bool
		return is(CHANGED_FILE)
	func changed_meta() -> bool
		return is(CHANGED_META)
	func mergeable(f: LocalFile) -> bool
		if size != f.size
			return false
		if id != f.id
			if len(id) > 0 and len(f.id) > 0
				return false
		return true
	func mut merge(f: LocalFile)
		for o in f.options
			set(o)
	func mut sync_tags(rtags: Tag[])
		tags = rtags # TODO
		db.dirty = true
	func mut set_name(_name: string)
		if _name == name
			return
		name = _name
		db.dirty = true
		if conf.verbosity > 0
			log_ok("name", name)
		set(CHANGED_META)
	func mut tag_add(tt: Tag)
		if tt.key == "name"
			set_name(tt.value)
			return
		for t in tags
			if t.key == tt.key and t.value == tt.value
				return
		tags.add(tt)
		db.dirty = true
		if conf.verbosity > 0
			log_ok("tag add", "{{tt}}")
		set(CHANGED_META)
	func mut tag_set(tt: Tag)
		if tt.key == "name"
			set_name(tt.value)
			return
		for t in tags
			if t.key == tt.key
				if t.value == tt.value
					return
				if conf.verbosity > 0
					log_ok("tag set", "{{t}}  ->  {{tt.value}}")
				t.value = tt.value
				db.dirty = true
				set(CHANGED_META)
				return
		tag_add(tt)
	func mut tag_rm(tt: Tag)
		for i=>t in tags
			if t.match(tt)
				if conf.verbosity > 0
					log_ok("tag rm", "{{t}}")
				tags.remove(i)
				db.dirty = true
				set(CHANGED_META)
				return
	func status_str() -> string
		if !in_db()
			return "? "
		if pure_local()
			return "L "
		if pure_remote()
			return "R "
		if changed_file()
			return "**"
		if changed_meta()
			return "* "
		return "  "
	func show_info(l: string)
		#print(l + "path: " + path)
		print(l + "name:    {{name}}")
		print(l + "id:      {{id}}")
		print(l + "hash:    {{hash}}")
		#print(l + "mtime:   {{mtime}}")
		#if remote_mtime != 0 and remote_mtime != mtime
		#	s += "\nmtime: " + mtime + " (REMOTE)"
		print(l + "size:    {{size}}")
		#print(l + "options: " + options)
		var _tags = tags_sort(tags)
		for t in _tags
			print(l + "  tag:   {{t.key}}={{t.value}}")
	func remote_path() -> string
		var ext = path.extension()
		if is("quality=medium")
			return ALEX_DIR + "medium/{{id}}.{{ext}}"
		return ALEX_DIR + "links/{{id}}"
	func get_tag(key: string) -> string
		if key == "name"
			return name
		if key == "ext"
			return path.extension()
		if key == "id"
			return id
		if key == "hash"
			return hash
		if key == "size"
			return str(size)
		for t in tags
			if t.key == key
				return t.value
		return ""
	func apply_structure(structure: string) -> string
		var r = structure
		var p1 = 0
		while true
			var p0 = r.find("{", p1)
			if p0 < 0
				break
			p1 = r.find("}", p0)
			if p1 < 0
				break
			var kkey = r[p0+1:p1]
			var xkey = kkey.explode("|")
			var val = get_tag(xkey[0])
			if len(xkey) >= 2
				val = str_format(val, xkey[1])
			
			r = r[:p0] + val + r[p1+1:]
			p1 = p0 + len(val)
		return r.replace("?", "").replace(":", "")
	func match(mtags: Tag[]) -> bool
		for mt in mtags
			var tag_match = false
			if mt.key == "name"
				tag_match = name.match(mt.value)
			else if mt.key == "id"
				tag_match = id.match(mt.value)
			else if mt.key == "hash"
				tag_match = hash.match(mt.value)
			else
				for t in tags
					#if t.key == mt.key and t.value == tm.value
					if t.key == mt.key and t.value.match(mt.value)
						tag_match = true
						break
			if !tag_match
				return false
		return true

func unique_path(f: LocalFile) -> Path
	var ext = f.path.extension()
	return f.path.parent() << "{{f.hash}} {{f.name}}.{{ext}}" 

class LocalFileDB
	var files: LocalFile[]
	var dirty = false
	
	func mut load()
		files.clear()
		dirty = false
		#Timer tt
		var ss = fs.read(hui.app_directory << "sisyphos/db")
		var lines = ss.explode("\n")
		if lines[0] == "version=2"
			load_v2(lines)
		else if lines[0] == "version=1"
			load_v1(lines[1:])
		else
			load_v1(lines)
		
	func mut load_v2(lines: string[])
		
	func mut load_v1(lines: string[])
		var n = len(lines) / 10
		for i in 0:n
			var ff: LocalFile
			var i0 = i*10+1
			ff.id = lines[i0]
			ff.path = Path(lines[i0+1])
			#ff.remote_path = lines[i0+2]
			ff.name = lines[i0+3]
			ff.hash = lines[i0+4]
			ff.mtime = int(lines[i0+5])
			ff.remote_mtime = int(lines[i0+6])
			ff.size = int(lines[i0+7])
			ff.options = lines[i0+8].explode(",")
			ff.tags = strh2tags(lines[i0+9])
			ff.unset("")
			if ff.hash == "d41d8cd98f00b204e9800998ecf8427e"
				ff.hash = ""
			if ff.id == "-1"
				ff.id = ""
	
			files.add(ff)
		#print(tt.get())

	func mut self_check()
		check_basic()
		check_hash_collisions()
		check_duplicate_paths()
	
	func mut check_basic()
		for f in files
			if f.path.is_empty()
				log_error("empty hash", "...")
				f.show_info("    ")
			if f.hash == ""
				if fs.exists(f.path)
					log_error("empty hash", f.path)
					f.hash = fs.hash(f.path, "md5")
					dirty = true
				else if f.id == ""
					log_error("ghost", f.path)
					f.drop_me = true
					dirty = true
				#else
					# hash='', id='', no file
					#print("EMPTY HASH (REMOTE): " + ff.path)
	func mut check_hash_collisions()
		for f in files
			if f.path.is_empty()
				continue
			var l = by_hash(f.hash)
			if l == &f
				continue
			if f.path == l.path
				log_error("duplicate", f.path)
				if l.mergeable(f)
					l.merge(f)
					dirty = true
					f.drop_me = true
				else
					print("   {{rel_path(f.path)}}   <->   {{rel_path(l.path)}}")
					print("###################################")
			else
				log_error("hash collision", "{{f.path}}  <->  {{l.path}}")

	func mut check_duplicate_paths()
		for f in files
			if f.path.is_empty()
				continue
			var l = find_by_path(f.path)
			if l == &f
				continue
			log_error("path collision", f.path)
			var new_path = unique_path(f)
			
			log_warn("move", "{{rel_path(f.path)}} > {{rel_path(new_path)}}")
			f.path = new_path
			db.dirty = true

	func mut drop_selected()
		for i in 0:len(files)
			if files[i].drop_me
				log_warn("drop", files[i].path)
				files.remove(i)
				db.dirty = true
				i --

	func mut save()
		make_all_dirs(hui.app_directory << "sisyphos")
		var f = new TextLinesFormatter(fs.open(hui.app_directory << "sisyphos/db", "wt"))
		f << "version=1"
		f << len(files)
		for ff in files
			f << ff.id
			f << str(ff.path)
			f << "" # ff.remote_path
			f << ff.name
			f << ff.hash
			f << ff.mtime
			f << ff.remote_mtime
			f << ff.size
			f << ff.options.join(",")
			f << tags2strh(ff.tags)
		del f
		dirty = false
	
	func const has_id(id: string) -> bool
		for f in files
			if id == f.id
				return true
		return false

	func selfref find_by_id(id: string) -> LocalFile*
		for f in files
			if id == f.id
				return &f
		raise(new Exception("not in db: id={{id}}"))

	func selfref find_by_path(path: Path) -> LocalFile*
		for f in files
			if path == f.path
				return &f
		raise(new Exception("not in db: '{{rel_path(path)}}'"))

	func const has_path(path: Path) -> bool
		for f in files
			if path == f.path
				return true
		return false

	func selfref by_hash(hash: string) -> LocalFile*
		if hash == ""
			raise(new Exception("invalid hash"))
		for f in files
			if hash == f.hash
				return &f
		raise(new Exception("not in db: hash={{hash}}"))

	#LocalFile *find_by_hash(string hash)
#		if hash == ""
#			raise(new Exception("invalid hash"))
#		for f in files
#			if hash == f.hash
#				return &f
#		raise(new Exception("not in db: hash=" + hash))
		
	func selfref find_by_tags(filter: string) -> LocalFile*[]
		var tags = str2tags(filter)
		var list: LocalFile*[]
		for f in files
			if f.match(tags)
				list.add(&f)
		return list |> sort("path")

	func selfref get_in_dir(dir: Path, recursive: bool) -> LocalFile*[]
			
		var list: LocalFile*[]
		if recursive
			for f in files
				if f.path in dir
					if !f.pure_local() and conf.filter_pure_local
						continue
					if !f.pure_remote() and conf.filter_pure_remote
						continue
					list.add(&f)
		else
			for f in files
				if f.path.parent() == dir
					if !f.pure_local() and conf.filter_pure_local
						continue
					if !f.pure_remote() and conf.filter_pure_remote
						continue
					list.add(&f)
		return list |> sort("path")

	func selfref get(path: Path, rec: bool) -> LocalFile*[]
		if fs.is_directory(path)
			return get_in_dir(path, rec)
		var files: LocalFile*[]
		try
			files.add(find_by_path(path))
		except
			pass
		return files
		
	func mut rehash()
		for f in files
			if f.pure_remote()
				continue
			print(f.path)
			try
				var h2 = fs.hash(f.path, "md5")
				if h2 != f.hash
					print("{{h2}} != {{f.hash}}")
					f.hash = h2
					save()
			except
				pass
	func mut optimize()
		print("optimizing...")
		files = files |> sort("path")
		dirty = true
	
	func mut manual_init()
		print("initializing")
		save()
		conf.save()
	
var db: LocalFileDB


