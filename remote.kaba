use "config.kaba"
use "localdb.kaba"
use "tag.kaba"


string scp_escape(string s)
	string r = s
	r = r.replace("(", "\\\\\\(")
	r = r.replace(")", "\\\\\\)")
	r = r.replace("'", "\\\\\\'")
	r = r.replace(" ", "\\\\\\ ")
	return r

string ssh_escape(string s)
	string r = s
	r = r.replace(" ", "\\\\ ")
	r = r.replace("(", "\\\\(")
	r = r.replace(")", "\\\\)")
	r = r.replace("'", "\\\\'")
	return r

void scp_download(string source, string dest)
	string cmd = "scp"
	string rp = scp_escape(source)
	cmd += " " + SERVER + ":" + rp
	cmd += " \"" + bash_escape(dest) + "\""
	if conf.verbose
		print(cmd)
	shell_execute(cmd)

void scp_upload(string source, string dest)
	string cmd = "scp"
	string rp = scp_escape(dest)
	cmd += " \"" + bash_escape(source) + "\""
	cmd += " " + SERVER + ":" + rp
	if conf.verbose
		print(cmd)
	shell_execute(cmd)

string yii(string action, string[] params)
	string cmd = "ssh " + SERVER + " command=\""
	
	cmd += "php " + YII + " " + action
	for p in params
		cmd += " \\\"" + ssh_escape(p) + "\\\""
	cmd += "; \""
	if conf.verbose
		print(cmd)
	return shell_exec(cmd).trim()

class RemoteFile extends LocalFile

RemoteFile[] remote_parse(string r)
	RemoteFile[] rfiles
	string[] list = r.explode("\n")
	for l in list
		string[] parts = l.explode("\t")
		if parts.num < 7
			continue
		RemoteFile rf
		rf.id = parts[0]
		rf.mtime = parts[1].int()
		rf.size = parts[2].int()
		rf.hash = parts[3]
		rf.remote_path = parts[4]
		rf.name = parts[5]
		string extension = parts[6]
		rf.path = rf.name + "." + extension // temporary
		for i in 8:parts.num
			rf.tags.add(str2tag(parts[i]))
		if parts[7] == "m"
			rf.set("quality=medium")
		rf.set(NONLOCAL)
		rfiles.add(rf)
	return rfiles

RemoteFile[] remote_find(string filter, string quality)
	string r = yii("file/find-sisyphos", [filter, quality])
	return remote_parse(r)

RemoteFile[] remote_find_by_hash(string hashes)
	string r = yii("file/info-by-hash-sisyphos", [hashes])
	return remote_parse(r)

RemoteFile[] remote_find_by_id(string ids, string quality)	
	string r = yii("file/info-by-id-sisyphos", [ids, quality])
	return remote_parse(r)



void sync_add_pure_remote(RemoteFile rf, string root, string structure)
	LocalFile *lf = db.find_by_id(rf.id)
	if !lf
		//string rel_name = sync.guess_dir(["parts"]) + rf.rel_name.replace("/", " - ")
		lf = db.find_by_hash(rf.hash)
		if lf
			if lf.id.num > 0
				print("HASH COLLISION  " + rel_path(lf.path) + "  <->  " + "REMOTE...")
			lf.id = rf.id
			//if conf.verbose
			print("RELINK  " + rel_path(lf.path))// + "  ->  " + rf.id)
			lf.sync_tags(rf.tags)
			lf.name = rf.name
			return
	
		// new remote file
		LocalFile ll = rf
		ll.path = ll.apply_structure(root, structure)
		ll.set(NONLOCAL)
		db.files.add(ll)
		print("ADD PURE REMOTE  " + rel_path(ll.path))
		
		if conf.show_meta or conf.verbose
			ll.show_info("      ")


void remote_sync_by_filter(string filter, string quality, string structure, string dir)
	RemoteFile[] rfiles = remote_find(filter, quality)
	for rf in rfiles
		LocalFile *lf = db.find_by_id(rf.id)
		if lf
			sync_file(rf, lf)
		else
			sync_add_pure_remote(rf, dir, structure)
	db.save()

void remote_download(LocalFile* f)
	if !f.in_db()
		print("ERROR: not in db")
		return

	if !f.pure_remote() and !f.is(CHANGED_FILE)
		print("ERROR: neither pure remote nor changed")
		return
	if f.remote_path.num == 0
		print("ERROR: no remote path")
		return
	
	make_all_dirs(f.path)
	scp_download(f.remote_path, f.path)

	File *ff = FileOpen(f.path)
	if ff
		f.size = ff.getSize()
		f.mtime = ff.getMDate().time
		f.hash = FileHash(f.path, "md5")
		f.unset(NONLOCAL)
		f.unset(CHANGED_FILE)
		db.save()
		delete ff
		return
	print("---ERROR---")


void remote_upload(LocalFile* f)
	
	if !f.pure_local()
		print("ERROR: not pure local")
		return
	
	if f.path.extension() == ""
		print("ERROR: remote does not like files without extension: " + rel_path(f.path))
		return
	
	f.remote_path = ALEX_IN + f.hash + "." + f.path.extension()
	
	scp_upload(f.path, f.remote_path)

	string tags = tags2str(f.tags)	
		
	string r = yii("file/upload-sisyphos", [f.remote_path, f.name, f.hash, tags])
	
	string[] p = r.explode("\t")
	if p.num >= 2
		if p[0] == "ok"
			f.id = p[1]
			db.save()
			return
		if p[0] == "duplicate"
			print("hash already in db  -> RELINK")
			f.id = p[1]
			db.save()
			return
		if p[0] == "bad hash"
			print("ERROR: upload failed?")
			return
	print("ERROR: ????")


void remote_upload_meta(LocalFile* f)
	
	if f.pure_local()
		print("ERROR: pure local")
		return

	string tags = tags2str(f.tags)	
	
	string r = yii("file/override-meta-sisyphos", [f.id, f.name, tags])
	
	if r == "ok"
		if conf.verbose
			print("yay")
		f.unset(CHANGED_META)
		db.save()
		return
	if r == "not found"
		print("ERROR: remote did not find")
		return
	print("ERROR: ????")


RemoteFile[] remote_get_meta(LocalFile*[] files)

	string[] ids_perfect
	string[] ids_medium
	for f in files
		if f.is("quality=medium")
			ids_medium.add(f.id)
		else
			ids_perfect.add(f.id)
	RemoteFile[] rfiles, rfiles_medium
	if ids_perfect.num > 0
		rfiles = remote_find_by_id(ids_perfect.join(","), PERFECT)
	if ids_medium.num > 0
		rfiles_medium = remote_find_by_id(ids_medium.join(","), MEDIUM)
	for rf in rfiles_medium
		rfiles.add(rf)
	return rfiles

void remote_download_meta(LocalFile*[] files)
	RemoteFile[] rfiles = remote_get_meta(files)
	for rf in rfiles
		LocalFile* lf = db.find_by_id(rf.id)
		if lf
			print("META  " + rel_path(lf.path))
			lf.unset(CHANGED_META)
			lf.name = rf.name
			lf.tags = rf.tags
			db.dirty = true

void remote_sync_by_id(string _dir)
	LocalFile*[] files = db.get_in_dir(_dir, conf.recursive)
	LocalFile*[] files_wanted
	for f in files
		if !f.pure_remote() and !f.pure_local()
			files_wanted.add(f)
	RemoteFile[] rfiles = remote_get_meta(files_wanted)
	for rf in rfiles
		LocalFile* lf = db.find_by_id(rf.id)
		if lf
			sync_file(rf, lf)

void sync_file(RemoteFile rf, LocalFile* lf)
	lf.unset(CHANGED_FILE)
	lf.unset(CHANGED_META)
	lf.remote_path = rf.remote_path
	db.dirty = true
	if rf.is("quality=medium")
		lf.set("quality=medium")
	if lf.pure_local()
		print("RELINK  " + rel_path(lf.path))
		lf.id = rf.id
		//db.dirty = true
	if lf.hash != rf.hash
		print("CHANGED HASH  " + rel_path(lf.path))
		if conf.verbose
			print(lf.hash)
			print(rf.hash)
		lf.set(CHANGED_FILE)
		//db.dirty = true
	if lf.name != rf.name
		print("CHANGED NAME  " + rel_path(lf.path))
		if conf.verbose
			print(lf.name + " <-> " + rf.name)
		lf.set(CHANGED_META)
		//db.dirty = true
	if !tags_equal(lf.tags, rf.tags)
		print("CHANGED TAGS  " + rel_path(lf.path))
		if conf.verbose
			print(tags2str(tags_sort(lf.tags)))
			print(tags2str(tags_sort(rf.tags)))
		lf.set(CHANGED_META)
		//db.dirty = true


void remote_sync_pure_locals_by_hash(string _dir)
	LocalFile*[] files = db.get_in_dir(_dir, conf.recursive)
	string[] hashes
	for f in files
		if f.pure_local()
			hashes.add(f.hash)
	if hashes.num == 0
		return
	RemoteFile[] rfiles = remote_find_by_hash(hashes.join(","))
	for rf in rfiles
		if conf.verbose
			print(rf.hash)
		try
			LocalFile* lf = db.find_by_hash(rf.hash)
			if conf.verbose
				print(lf.path)
			sync_file(rf, lf)
		except
			print("SHOULD NOT BE HERE...")

