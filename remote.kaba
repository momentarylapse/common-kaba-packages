use "config.kaba"
use "localdb.kaba"
use "tag.kaba"


string scp_escape(string s)
	string r = s
	r = r.replace("(", "\\\\\\(")
	r = r.replace(")", "\\\\\\)")
	r = r.replace("'", "\\\\\\'")
	r = r.replace(" ", "\\\\\\ ")
	return r

string ssh_escape(string s)
	string r = s
	r = r.replace(" ", "\\\\ ")
	r = r.replace("(", "\\\\(")
	r = r.replace(")", "\\\\)")
	r = r.replace("'", "\\\\'")
	return r


class RemoteFile extends LocalFile

RemoteFile[] remote_parse(string r, string options)
	RemoteFile[] rfiles
	string[] list = r.explode("\n")
	for l in list
		string[] parts = l.explode("\t")
		if parts.num < 7
			continue
		RemoteFile rf
		rf.id = parts[0]
		rf.mtime = parts[1].int()
		rf.size = parts[2].int()
		rf.hash = parts[3]
		rf.remote_path = parts[4]
		rf.name = parts[5]
		string extension = parts[6]
		rf.path = rf.name + "." + extension // temporary
		for i in 7:parts.num
			rf.tags.add(str2tag(parts[i]))
		rf.options = options.explode(",")
		rfiles.add(rf)
	return rfiles

RemoteFile[] remote_find(string filter, string options)
	string cmd = "ssh " + SERVER + " command=\""
	
	string quality = "perfect"
	if options.find("quality=medium", 0) >= 0
		quality = "medium"
	cmd += "php " + YII + " file/find-sisyphos \\\"" + ssh_escape(filter) + "\\\" " + quality + "; "
	cmd += "\""
	if conf.verbose
		print(cmd)
	_exec_(cmd + " > " + TEMP_OUT)
		
	//tocopy.clear()
	//copysize = 0
	
	string r = FileRead(TEMP_OUT).trim()
	return remote_parse(r, options)
	//string[] rs = r.explode("-=-=-=-=-=\n")
	//return rs

RemoteFile[] remote_info(string id, string options)
	string cmd = "ssh " + SERVER + " command=\""
	
	string quality = "perfect"
	if options.find("quality=medium", 0) >= 0
		quality = "medium"
	cmd += "php " + YII + " file/info-sisyphos " + id + " " + quality + "; "
	cmd += "\""
	if conf.verbose
		print(cmd)
	_exec_(cmd + " > " + TEMP_OUT)
		
	//tocopy.clear()
	//copysize = 0
	
	string r = FileRead(TEMP_OUT).trim()
	return remote_parse(r, options)
	//string[] rs = r.explode("-=-=-=-=-=\n")
	//return rs

RemoteFile[] remote_find_by_hash(string hashes)
	string cmd = "ssh " + SERVER + " command=\""
	
	cmd += "php " + YII + " file/info-by-hash-sisyphos " + hashes + "; "
	cmd += "\""
	if conf.verbose
		print(cmd)
	_exec_(cmd + " > " + TEMP_OUT)
		
	//tocopy.clear()
	//copysize = 0
	
	string r = FileRead(TEMP_OUT).trim()
	return remote_parse(r, "")
	//string[] rs = r.explode("-=-=-=-=-=\n")
	//return rs



void remote_sync_file(RemoteFile rf, ConfigDir e, ConfigDirSync sync)
	LocalFile *lf = db.find_by_id(rf.id)
	if lf
		if conf.pull_tags
			lf.sync_tags(rf.tags)
		lf.remote_path = rf.remote_path
		lf.name = rf.name
		
		// equal?
		if lf.hash == rf.hash
			if conf.verbose
				print("==  " + lf.path)
			return
		
		print("CHANGED  " + lf.path)
		/*if lf.is("nonlocal")
			FileToCopy ff
			ff.id = rf.id
			ff.remotepath = rf.path
			tocopy.add(ff)
			copysize += lf.size / 1024
			continue*/
				
		// ok... but should check for changes
	else
		//string rel_name = sync.guess_dir(["parts"]) + rf.rel_name.replace("/", " - ")
		lf = db.find_by_hash(rf.hash)
		if lf
			if lf.id.num > 0
				print("HASH COLLISION  " + lf.path + "  <->  " + "REMOTE...")
			lf.id = rf.id
			//if conf.verbose
			print("RELINK  " + lf.path)// + "  ->  " + rf.id)
			lf.sync_tags(rf.tags)
			lf.name = rf.name
			return
	
		// new remote file
		LocalFile ll = rf
		ll.path = ll.apply_structure(e)
		ll.set("nonlocal")
		db.files.add(ll)
		print("+R  " + ll.path)
		
		if conf.verbose
			print("    id:   " + ll.id)
			print("    hash: " + ll.hash)
			print("    time: " + ll.mtime)
			print("    size: " + ll.size)

void remote_sync(string dir)
	set_working_dir(dir)
	
	ConfigDir* e = conf.get_cfg(dir)
	for s in e.syncs
		RemoteFile[] rfiles = remote_find(s.filter, s.options)
		for f in rfiles
			remote_sync_file(f, *e, s)
		db.save()


void remote_find_and_show(string filter)
	RemoteFile[] rfiles = remote_find(filter, "")
	for f in rfiles
		f.show()
		if conf.verbose
			f.show_info("      ")

void remote_download(string path)
	LocalFile* f = db.find_by_path(path)
	if !f
		print("ERROR: not in db")
		return

	if !f.is("nonlocal")
		print("ERROR: no nonlocal")
		return
	if f.remote_path.num == 0
		print("ERROR: no remote path")
		return
	
	make_all_dirs(f.path)
	string cmd = "scp"
	string rp = scp_escape(f.remote_path)
	cmd += " " + SERVER + ":" + rp
	cmd += " \"" + bash_escape(f.path) + "\""
	if conf.verbose
		print(cmd)
	_exec_(cmd)
	
	File *ff = FileOpen(f.path)
	if ff
		if ff.getSize() == f.size
			f.unset("nonlocal")
			db.save()
			delete ff
			return
		delete ff
	print("---Fehler---")


void remote_upload(string path)
	LocalFile* f = db.find_by_path(path)
	if !f
		print("ERROR: not in db")
		return

	if f.id.num > 0
		print("ERROR: not pure local")
		return
	
	f.remote_path = ALEX_IN + f.hash + "." + f.path.extension()
	
	string cmd = "scp"
	string rp = scp_escape(f.remote_path)
	cmd += " \"" + bash_escape(f.path) + "\""
	cmd += " " + SERVER + ":" + rp
	if conf.verbose
		print(cmd)
	_exec_(cmd)
	

	string tags = tags2str(f.tags)	
	
	cmd = "ssh " + SERVER + " command=\""
	cmd += "php " + YII + " file/upload-sisyphos \\\"" + ssh_escape(f.remote_path) + "\\\" \\\"" + f.name + "\\\" " + f.hash + " \\\"" + tags + "\\\" ; "
	cmd += "\""
	if conf.verbose
		print(cmd)
	_exec_(cmd + " > " + TEMP_OUT)
	
	string r = FileRead(TEMP_OUT).trim()
	
	string[] p = r.explode("\t")
	if p.num >= 2
		if p[0] == "ok"
			f.id = p[1]
			db.save()
			return
		if p[0] == "duplicate"
			print("hash already in db  -> RELINK")
			f.id = p[1]
			db.save()
			return
		if p[0] == "bad hash"
			print("ERROR: upload failed?")
			return
	print("ERROR: ????")


void remote_pull()
	for f in db.files
		if f.is("nonlocal")
			remote_download(f.path)


void remote_sync_pure_locals_by_hash(string _dir)
	LocalFile*[] files = db.get_in_dir(_dir)
	string[] hashes
	for f in files
		if f.pure_local()
			hashes.add(f.hash)
	if hashes.num == 0
		return
	RemoteFile[] rfiles = remote_find_by_hash(hashes.join(","))
	for rf in rfiles
		LocalFile* lf = db.find_by_hash(rf.hash)
		if lf
			print("RELINK " + lf.path)
			lf.id = rf.id
			lf.sync_tags(rf.tags)
			lf.remote_path = rf.remote_path
			lf.name = rf.name
			db.dirty = true
		//f.show()

