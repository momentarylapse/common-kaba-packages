use os
use hui
use config
use tag

const string NONLOCAL = "nonlocal"
const string CHANGED_FILE = "changed"
const string CHANGED_META = "changed-meta"

class LocalFile
	bool drop_me

	# remote
	string id
	string name
	int remote_mtime
	string remote_path
	# local
	string path
	string hash # can be "" if not local
	int mtime
	int size
	string[] options
	Tag[] tags
	
	void __init__()
		drop_me = false
	
	const bool is(string option)
		for o in options
			if o == option
				return true
		return false
	void set(string option)
		if is(option)
			return
		options.add(option)
		db.dirty = true
	void unset(string option)
		for o,i in options
			if o == option
				options.remove(i)
				db.dirty = true
				return
	const bool pure_remote()
		return is(NONLOCAL)
	const bool pure_local()
		return id.num == 0
	const bool perfectly_fine()
		if pure_remote() or pure_local()
			return false
		if changed_meta() or changed_file()
			return false
		return true
	const bool in_db()
		return hash.num > 0
	const bool changed_file()
		return is(CHANGED_FILE)
	const bool changed_meta()
		return is(CHANGED_META)
	const bool mergeable(LocalFile* f)
		if size != f.size
			return false
		if id != f.size
			if id.num > 0 and f.id.num > 0
				return false
		return true
	void merge(LocalFile* f)
		for o in f.options
			set(o)
	void sync_tags(Tag[] rtags)
		tags = rtags # TODO
		db.dirty = true
	void set_name(string _name)
		name = _name
		db.dirty = true
		if conf.verbosity > 0
			print("NAME  {{name}}")
		set(CHANGED_META)
	void tag_add(Tag tt)
		if tt.key == "name"
			set_name(tt.value)
			return
		for t in tags
			if t.key == tt.key and t.value == tt.value
				return
		tags.add(tt)
		db.dirty = true
		if conf.verbosity > 0
			print("TAG ADD  {{tt}}")
		set(CHANGED_META)
	void tag_set(Tag tt)
		if tt.key == "name"
			set_name(tt.value)
			return
		for t in tags
			if t.key == tt.key
				if t.value == tt.value
					return
				if conf.verbosity > 0
					print("TAG SET  {{t}}  ->  {{tt.value}}")
				t.value = tt.value
				db.dirty = true
				set(CHANGED_META)
				return
		tag_add(tt)
	void tag_rm(Tag tt)
		for t,i in tags
			if t.match(tt)
				if conf.verbosity > 0
					print("TAG RM  {{t}}")
				tags.remove(i)
				db.dirty = true
				set(CHANGED_META)
				return
	const string status_str()
		if !in_db()
			return "?   "
		if pure_local()
			return "L   "
		if pure_remote()
			return "R   "
		if changed_file()
			return "**  "
		if changed_meta()
			return "*   "
		return "    "
	const void show()
		if pure_remote()
			print(status_str() + remote_path)
		else
			print(status_str() + rel_path(path))
	const void show_info(string l)
		#print(l + "path: " + path)
		print(l + "name:    {{name}}")
		print(l + "id:      {{id}}")
		print(l + "hash:    {{hash}}")
		#print(l + "mtime:   {{mtime}}")
		#if remote_mtime != 0 and remote_mtime != mtime
		#	s += "\nmtime: " + mtime + " (REMOTE)"
		print(l + "size:    {{size}}")
		#print(l + "options: " + options)
		let _tags = tags_sort(tags)
		for t in _tags
			print(l + "  tag:   {{t.key}}={{t.value}}")
	const string get_tag(string key)
		if key == "name"
			return name
		if key == "ext"
			return path.extension()
		if key == "id"
			return id
		if key == "hash"
			return hash
		for t in tags
			if t.key == key
				return t.value
		return ""
	const string apply_structure(string root, string structure)
		if structure == ""
			if path.find(root, 0) == 0
				return path
			else
				return root + path
		string spath = structure
		int p1 = 0
		while true
			int p0 = structure.find("{", p1)
			if p0 < 0
				break
			p1 = structure.find("}", p0)
			if p1 < 0
				break
			let kkey = structure[p0+1:p1]
			let xkey = kkey.explode(":")
			let val = get_tag(xkey[0])
			if xkey.num > 1
				int n = xkey[1].int()
				while val.num < n
					val = "0" + val
			spath = spath.replace("{" + kkey + "}", val)
		return root + spath
	const bool match(Tag[] mtags)
		for mt in mtags
			bool tag_match = false
			if mt.key == "name"
				tag_match = name.match(mt.value)
			else if mt.key == "id"
				tag_match = id.match(mt.value)
			else if mt.key == "hash"
				tag_match = hash.match(mt.value)
			else
				for t in tags
					#if t.key == mt.key and t.value == tm.value
					if t.key == mt.key and t.value.match(mt.value)
						tag_match = true
						break
			if !tag_match
				return false
		return true

class LocalFileDB
	LocalFile[] files
	bool dirty
	
	void load()
		files.clear()
		dirty = false
		#Timer tt
		let ss = Filesystem.read(AppDirectory + "sisyphos/db")
		let lines = ss.explode("\n")
		int n = len(lines) / 10
		for i in 0:n
			LocalFile ff
			int i0 = i*10+1
			ff.id = lines[i0]
			ff.path = lines[i0+1]
			ff.remote_path = lines[i0+2]
			ff.name = lines[i0+3]
			ff.hash = lines[i0+4]
			ff.mtime = lines[i0+5].int()
			ff.remote_mtime = lines[i0+6].int()
			ff.size = lines[i0+7].int()
			ff.options = lines[i0+8].explode(",")
			ff.tags = strh2tags(lines[i0+9])
			ff.unset("")
			if ff.hash == "d41d8cd98f00b204e9800998ecf8427e"
				ff.hash = ""
			if ff.id == "-1"
				ff.id = ""
	
			files.add(ff)
		#print(tt.get())

	void self_check()
		for f in files
			if f.path.num == 0
				print("EMPTY PATH ...")
				f.show_info("    ")
			if f.hash == ""
				if Filesystem.exists(f.path)
					print("EMPTY HASH: {{f.path}}")
					f.hash = Filesystem.hash(f.path, "md5")
					dirty = true
				else if f.id == ""
					print("GHOST: {{f.path}}")
					f.drop_me = true
					dirty = true
				#else
					# hash='', id='', no file
					#print("EMPTY HASH (REMOTE): " + ff.path)
			if f.path.num > 0
				LocalFile *l = by_hash(f.hash)
				if l and l != &f
					if f.path == l.path
						print("DUPLICATE: {{f.path}}")
						if l.mergeable(&f)
							l.merge(&f)
							dirty = true
							f.drop_me = true
						else
							f.show()
							print("   <->")
							l.show()
							print("###################################")
					else
						print("HASH COLLISION: {{f.path}}  <->  {{l.path}}")

	void drop_selected()
		for i in 0:files.num
			if files[i].drop_me
				print("DROP {{files[i].path}}")
				files.remove(i)
				db.dirty = true
				i --

	void save()
		File *f = Filesystem.create_text(AppDirectory + "sisyphos/db")
		f << files.num
		for ff in files
			f << ff.id
			f << ff.path
			f << ff.remote_path
			f << ff.name
			f << ff.hash
			f << ff.mtime
			f << ff.remote_mtime
			f << ff.size
			f << ff.options.join(",")
			f << tags2strh(ff.tags)
		del f
		dirty = false
	
	const bool has_id(string id)
		for f in files
			if id == f.id
				return true
		return false

	const LocalFile *find_by_id(string id)
		for f in files
			if id == f.id
				return &f
		raise(new Exception("not in db: id={{id}}"))

	const LocalFile *find_by_path(string path)
		for f in files
			if path == f.path
				return &f
		raise(new Exception("not in db: '{{rel_path(path)}}'"))

	const bool has_path(string path)
		for f in files
			if path == f.path
				return true
		return false

	const LocalFile *by_hash(string hash)
		if hash == ""
			raise(new Exception("invalid hash"))
		for f in files
			if hash == f.hash
				return &f
		raise(new Exception("not in db: hash={{hash}}"))

	#LocalFile *find_by_hash(string hash)
#		if hash == ""
#			raise(new Exception("invalid hash"))
#		for f in files
#			if hash == f.hash
#				return &f
#		raise(new Exception("not in db: hash=" + hash))
		
	const LocalFile*[] find_by_tags(string str)
		Tag[] tags = str2tags(str)
		LocalFile*[] list
		for f in files
			if f.match(tags)
				list.add(&f)
		return sorted(list, "path")

	const LocalFile*[] get_in_dir(string _dir, bool recursive)
		string dir = dir_canonical(_dir)
			
		LocalFile*[] list
		if recursive
			for f in files
				if f.path.head(dir.num) == dir
					if !f.pure_local() and conf.filter_pure_local
						continue
					if !f.pure_remote() and conf.filter_pure_remote
						continue
					list.add(&f)
		else
			for f in files
				if f.path.dirname() == dir
					if !f.pure_local() and conf.filter_pure_local
						continue
					if !f.pure_remote() and conf.filter_pure_remote
						continue
					list.add(&f)
		return sorted(list, "path")

	const LocalFile*[] get(string path, bool rec)
		if Filesystem.is_directory(path)
			return get_in_dir(path, rec)
		LocalFile*[] files
		try
			files.add(find_by_path(path))
		except
			pass
		return files
		
	void rehash()
		for f in files
			if f.pure_remote()
				continue
			print(f.path)
			try
				string h2 = Filesystem.hash(f.path, "md5")
				if h2 != f.hash
					print("{{h2}} != {{f.hash}}")
					f.hash = h2
					save()
			except
				pass
	void optimize()
		print("optimizing...")
		files = sorted(files, "path")
		dirty = true
	
LocalFileDB db



void auto_tag(out LocalFile f)
	if !Filesystem.exists(f.path)
		return
	let ext = f.path.extension()
	#print(ext)
	try
		if ext == "pdf"
			let s = shell_exec("pdfinfo \"{{bash_escape(f.path)}}\" | awk '/Pages/{print $2}'")
			if s.num > 0
				f.tag_set(Tag("pages", str(int(s))))
		else if ext in ["png", "bmp"] #, "jpg"]
			let s = shell_exec("identify -format \"%w\n%h\" \"{{bash_escape(f.path)}}\"").explode("\n")
			if s.num >= 2
				f.tag_set(Tag("width", str(int(s[0]))))
				f.tag_set(Tag("height", str(int(s[1]))))
		else if ext == "jpg"
			let s = shell_exec("exiv2 -pv \"{{bash_escape(f.path)}}\"").explode("\n")
			string model, make, time
			for l in s
				for i in 0:20
					l = l.replace("  ", " ")
				let xx = l.explode(" ")
				if len(xx) < 6
					continue
				if xx[0] == "0xa002" # PixelXDimension
					f.tag_set(Tag("width", int(xx[5])))
				if xx[0] == "0xa003" # PixelYDimension
					f.tag_set(Tag("height", int(xx[5])))
				if xx[0] == "0x0110" # Model
					model = xx[5:].join(" ")
				if xx[0] == "0x010f" # Make
					make = xx[5:].join(" ")
				if xx[0] == "0x829a" # ExposureTime
					f.tag_set(Tag("exposuretime", xx[5]))
				if xx[0] == "0x829d"
					print(xx[2] + " " + xx[5])
					#f.tag_set(Tag("fnumber", xx[5]))
				if xx[0] == "0x8827" # ISOSpeedRatings
					f.tag_set(Tag("iso", xx[5]))
				if xx[0] in ["0x0132", "0x9003"] # DateTime
					time = xx[5] + " " + xx[6]
			if len(time) == 19
				if time[4] == ':'
					f.tag_set(Tag("year", time[:4]))
					f.tag_set(Tag("month", str(int(time[5:7]))))
					f.tag_set(Tag("day", str(int(time[8:10]))))
					f.tag_set(Tag("timeofday", time[11:]))
			if len(make) > 0 and len(model) > 0
				f.tag_set(Tag("camera", "{{make}} {{model}}"))
		else if ext == "jpg--"
			let s = shell_exec("exif -mi \"{{bash_escape(f.path)}}\" || echo --end--").explode("\n")
			string model, make, time
			for l in s
				let xx = l.explode("\t")
				if len(xx) < 2
					continue
				if xx[0] == "0xa002"
					f.tag_set(Tag("width", xx[1].int()))
				if xx[0] == "0xa003"
					f.tag_set(Tag("height", xx[1].int()))
				if xx[0] == "0x0110"
					model = xx[1]
				if xx[0] == "0x010f"
					make = xx[1]
				if xx[0] == "0x829a"
					f.tag_set(Tag("exposuretime", xx[1]))
				if xx[0] == "0x829d"
					f.tag_set(Tag("fnumber", xx[1]))
				if xx[0] == "0x8827"
					f.tag_set(Tag("iso", xx[1]))
				if xx[0] in ["0x0132", "0x9003"]
					time = xx[1]
			if len(time) == 19
				if time[4] == ':'
					f.tag_set(Tag("year", time[:4]))
					f.tag_set(Tag("month", str(int(time[5:7]))))
					f.tag_set(Tag("day", str(int(time[8:10]))))
					f.tag_set(Tag("timeofday", time[11:]))
			if len(make) > 0 and len(model) > 0
				f.tag_set(Tag("camera", "{{make}} {{model}}"))
		else if ext in ["nami", "ogg", "flac", "wav", "mid", "mp3"]
			let s = shell_exec("tsunami --info \"{{bash_escape(f.path)}}\"").explode("\n")
			int samples = -1
			int sample_rate = 44100
			for l in s
				if l[:9] == "samples: "
					samples = l[9:].int()
				else if l[:13] == "sample-rate: "
					sample_rate = l[13:].int()
				else if l[:13] == "tag: title = "
					f.set_name(l[13:])
				else if l[:14] == "tag: artist = "
					f.tag_set(Tag("artist", l[14:]))
				else if l[:13] == "tag: album = "
					f.tag_set(Tag("album", l[13:]))
			if samples >= 0
				f.tag_set(Tag("length", samples / sample_rate))
	except Exception as e
		error_out(e)
