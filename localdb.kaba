use "config.kaba"
use "tag.kaba"

const string NONLOCAL = "nonlocal"
const string CHANGED = "changed"

class LocalFile
	bool drop_me

	// remote
	string id
	string name
	int remote_mtime
	string remote_path
	// local
	string path
	string hash // can be "" if not local
	int mtime
	int size
	string[] options
	Tag[] tags
	
	void __init__()
		drop_me = false
	
	bool is(string option)
		for o in options
			if o == option
				return true
		return false
	void set(string option)
		if is(option)
			return
		options.add(option)
	void unset(string option)
		for o,i in options
			if o == option
				options.remove(i)
				return
	bool pure_remote()
		return is(NONLOCAL)
	bool pure_local()
		return id.num == 0
	bool in_db()
		return hash.num > 0
	bool changed()
		return is(CHANGED)
	bool mergeable(LocalFile* f)
		if size != f.size
			return false
		if id != f.size
			if id.num > 0 and f.id.num > 0
				return false
		return true
	void merge(LocalFile* f)
		for o in f.options
			set(o)
	void sync_tags(Tag[] rtags)
		tags = rtags // TODO
	void tag_add(string key, string value)
		if key == "name"
			name = value
			set(CHANGED)
			return
		for t in tags
			if t.key == key and t.value == value
				return
		Tag t
		t.key = key
		t.value = value
		tags.add(t)
		set(CHANGED)
	void tag_set(string key, string value)
		for t in tags
			if t.key == key
				t.value = value
				set(CHANGED)
				return
		tag_add(key, value)
	void tag_rm(string key, string value)
		for t,i in tags
			if t.key == key and t.value == value
				tags.remove(i)
				set(CHANGED)
				return
	string status_str()
		if !in_db()
			return "?   "
		if pure_local()
			return "L   "
		if pure_remote()
			return "R   "
		if changed()
			return "C   "
		return "    "
	void show()
		print(status_str() + rel_path(path))
	void show_info(string l)
		//print(l + "path: " + path)
		print(l + "name:    " + name)
		print(l + "id:      " + id)
		print(l + "hash:    " + hash)
		//print(l + "mtime:   " + mtime)
		//if remote_mtime != 0 and remote_mtime != mtime
		//	s += "\nmtime: " + mtime + " (REMOTE)"
		print(l + "size:    " + size)
		//print(l + "options: " + options)
		for t in tags
			print(l + "  tag:   " + t.key + " = " + t.value)
	string get_tag(string key)
		if key == "name"
			return name
		if key == "ext"
			return path.extension()
		for t in tags
			if t.key == key
				return t.value
		return ""
	string apply_structure(ConfigDir e)
		if e.structure == ""
			if path.find(e.dir, 0) == 0
				return path
			else
				return e.dir + path
		string spath = e.structure
		int p1 = 0
		while true
			int p0 = e.structure.find("{", p1)
			if p0 < 0
				break
			p1 = e.structure.find("}", p0)
			if p1 < 0
				break
			string kkey = e.structure.substr(p0+1,p1-p0-1)
			string[] xkey = kkey.explode(":")
			string val = get_tag(xkey[0])
			if xkey.num > 1
				int n = xkey[1].int()
				while val.num < n
					val = "0" + val
			spath = spath.replace("{" + kkey + "}", val)
		return e.dir + spath


class DBVisitor
	LocalFileDB* db
	string[] paths
	LocalFile*[] files
	LocalFile[] fake_files
	
	void __init__(LocalFileDB *_db)
		db = _db
				
	bool is_ignored(string path)
		for i in conf.ignore
			if path.match(i)
				return true
		return false

	void find_paths(string _dir)
		string dir = dir_canonical(_dir)
		DirEntry[] list = DirSearch(dir, "*", true)
		for e in list
			if e.is_dir
				if e.name.head(1) != "."
					find_paths(dir + e.name)
			else
				string path = (dir + e.name)
				if !is_ignored(path)
					paths.add(path)
	void sort_files()
		for i in 0:files.num
			for j in i+1:files.num
				if files[i].path > files[j].path
					LocalFile* f = files[i]
					files[i] = files[j]
					files[j] = f
	
	void recurse(string dir)
		if !FileIsDirectory(dir)
			LocalFile* f = db.find_by_path(dir)
			if f
				visit(f)
				return
			if FileExists(dir)
				LocalFile ff
				ff.path = dir
				visit(&ff)
			return

		files = db.get_in_dir(dir)
		
		find_paths(dir)
		for p in paths
			if !db.find_by_path(p)
				LocalFile f
				f.path = p
				fake_files.add(f)
		for f in fake_files
			files.add(&f)
		sort_files()
		for f in files
			visit(f)
		files.clear()
		fake_files.clear()
		paths.clear()
		
	virtual void visit(LocalFile* f)


// "add"
class DBUpdater extends DBVisitor
	override void __init__(LocalFileDB* _db)
		super.__init__(_db)
	override void visit(LocalFile* f)
		if f.in_db()
		
			// suddenly appearing?!?
			if f.pure_remote()
				if FileExists(f.path)
					f.unset(NONLOCAL)
					print("NON-NONLOCAL " + f.path)
					return
			
			// lost?
			if !FileExists(f.path)
				if !f.pure_remote()
					f.set(NONLOCAL)
					print("LOST  " + f.path)
				return
			
			// time
			File* ff = FileOpen(f.path)
			int mtime = ff.getMDate().time
			if mtime == f.mtime
				if conf.verbose
					print("=  " + f.path)
			else
				// changed?
				string hash = FileHash(f.path, "md5")
				if hash == f.hash
					print("TOUCHED  " + f.path)
					// ok
					f.mtime = mtime
				else
					print("EDITED  " + f.path)
					f.set(CHANGED)
					f.hash = hash
					f.mtime = mtime
					f.size = ff.getSize()
					if conf.verbose
						f.show_info("      ")
			delete ff
		else
			// new file
			
			string hash = FileHash(f.path, "md5")
			LocalFile* ff = db.find_by_hash(hash)
			if ff
				// hash already in db?
				if FileExists(ff.path)
					print("ERROR: duplicate + " + f.path + " <-> " + ff.path)
					return
				print("MOVED  " + ff.path + " > " + f.path)
				ff.path = f.path
				db.dirty = true
			else
				// new
				print("ADD  " + f.path)
				f.name = f.path.basename()
				string ext = f.path.extension()
				if ext.num > 0
					f.name = f.name.head(f.name.num - ext.num - 1)
				//print(ext)
				//print(l.name)
				f.hash = hash
				File* fff = FileOpen(f.path)
				f.mtime = fff.getMDate().time
				f.size = fff.getSize()
				delete fff
				if conf.verbose
					f.show_info("      ")
				db.files.add(*f)

class DBStatusReporter extends DBVisitor
	override void __init__(LocalFileDB* _db)
		super.__init__(_db)
	override void visit(LocalFile* f)
		f.show()
		if conf.verbose
			f.show_info("      ")

class DBLister extends DBVisitor
	override void __init__(LocalFileDB* _db)
		super.__init__(_db)
	override void visit(LocalFile* f)
		f.show()
		if conf.verbose
			f.show_info("      ")
		
		
class DBDropper extends DBVisitor
	override void __init__(LocalFileDB* _db)
		super.__init__(_db)
	override void visit(LocalFile* f)
		f.drop_me = true

class LocalFileDB
	LocalFile[] files
	bool dirty
	
	void load()
		files.clear()
		dirty = false
		File *f = FileOpen("db")
		if !f
			return
		int n
		f >> n
		for i in 0:n
			LocalFile ff
			string temp
			f >> ff.id
			f >> ff.path
			f >> ff.remote_path
			f >> ff.name
			f >> ff.hash
			f >> ff.mtime
			f >> ff.remote_mtime
			f >> ff.size
			f >> temp
			ff.options = temp.explode(",")
			f >> temp
			ff.tags = strh2tags(temp)
			ff.unset("")
			if ff.hash == "d41d8cd98f00b204e9800998ecf8427e"
				ff.hash = ""
			if ff.id == "-1"
				ff.id = ""
				
			if ff.hash == ""
				if FileExists(ff.path)
					print("EMPTY HASH: " + ff.path)
					ff.hash = FileHash(ff.path, "md5")
					dirty = true
				else if ff.id == ""
					print("GHOST: " + ff.path)
					dirty = true
					continue
				//else
					// hash='', id='', no file
					//print("EMPTY HASH (REMOTE): " + ff.path)
			if ff.path.num > 0
				LocalFile *l = find_by_hash(ff.hash)
				if l
					if ff.path == l.path
						print("DUPLICATE: " + ff.path)
						if l.mergeable(&ff)
							l.merge(&ff)
							dirty = true
							continue
						else
							ff.show()
							print("   <->")
							l.show()
							print("###################################")
					else
						print("HASH COLLISION: " + ff.path + "  <->  " + l.path)
				files.add(ff)
		delete(f)
		if dirty
			save()


	void drop_selected()
		for i in 0:files.num
			if files[i].drop_me
				print("DROP " + files[i].path)
				files.remove(i)
				db.dirty = true
				i --

	void save()
		File *f = FileCreate("db")
		f << files.num
		for ff in files
			f << ff.id
			f << ff.path
			f << ff.remote_path
			f << ff.name
			f << ff.hash
			f << ff.mtime
			f << ff.remote_mtime
			f << ff.size
			f << ff.options.join(",")
			f << tags2strh(ff.tags)
		delete(f)
		dirty = false

	LocalFile *find_by_id(string id)
		for f in files
			if id == f.id
				return &f
		return nil

	LocalFile *find_by_path(string path)
		for f in files
			if path == f.path
				return &f
		return nil

	LocalFile *find_by_hash(string hash)
		if hash == ""
			return nil
		for f in files
			if hash == f.hash
				return &f
		return nil
		
	LocalFile*[] find_by_tags(string str)
		Tag[] tags = str2tags(str)
		LocalFile*[] list
		for f in files
			bool ok = true
			for t in tags
				bool found = false
				for tt in f.tags
					if tt.key == t.key and tt.value == t.value
						found = true
						break
				if !found
					ok = false
					break
			if ok
				list.add(&f)
		return list

	LocalFile*[] get_in_dir(string _dir)
		string dir = dir_canonical(_dir)
			
		LocalFile*[] list
		for f in files
			if f.path.head(dir.num) == dir
				list.add(&f)
		return list

	// check for local changes
	/*void __update_local(ConfigDir e)
		print("update local " + e.dir)
		
		DBUpdater* up = new DBUpdater(self)
		up.recurse(e.dir)
		delete up
		
		LocalFile*[] dbfiles = get_in_dir(e.dir, true)
		LocalFile[] todrop
		for ff in dbfiles
			if ff.pure_remote()
				print("+R " + ff.path)
				continue
					
			if FileExists(ff.path)
				nil
				// already checked...
			else
				print("-  " + ff.path)
				ff.set("deleted")
				
				if conf.drop_deleted
					todrop.add(*ff)
		
		for ff in todrop
			drop(ff)
			
		save()*/

	// check for local changes
	void add_recursive(string path)
		set_working_dir(path)
		
		DBVisitor* vis = new DBUpdater(self)
		vis.recurse(path)
		delete vis
		
		/*LocalFile[] dbfiles = get_in_dir(e.dir, true)
		LocalFile[] todrop
		for ff in dbfiles
			if ff.is("nonlocal")
				print("+R " + ff.path)
				continue
					
			if FileExists(ff.path)
				nil
				// already checked...
			else
				print("-  " + ff.path)
				ff.set("deleted")
				
				if conf.drop_deleted
					todrop.add(ff)
		
		for ff in todrop
			drop(ff)*/
			
		save()

	void rm_recursive(string path)
		set_working_dir(path)
		
		DBVisitor* vis = new DBDropper(self)
		vis.recurse(path)
		delete vis
			
		save()
	
	void mv(string source, string dest)
		LocalFile* f = db.find_by_path(source)
		if !f
			print("ERROR: not in db")
			return
		if FileExists(dest) or db.find_by_path(dest)
			print("ERROR: dest not available")
			return
		f.path = dest
		db.save()
		
		if FileExists(source)
			make_all_dirs(dest)
			FileRename(source, dest)
	
	void rehash()
		for f in files
			if f.pure_remote()
				continue
			print(f.path)
			string h2 = FileHash(f.path, "md5")
			if h2.num == 0
				continue
			if h2 != f.hash
				print(h2 + " != " + f.hash)
				f.hash = h2
				save()
	void cleanup_structure(string _dir)
		set_working_dir(_dir)
		string dir = dir_canonical(_dir)
		LocalFile*[] files = db.get_in_dir(dir)
		for f in files
			ConfigDir* e = conf.get_cfg(f.path)
			if !e
				continue
			string new_path = f.apply_structure(*e)
			if f.path == new_path
				continue
			print(f.path + " -> " + new_path)
			make_all_dirs(new_path)
			_exec_("mv \"" + bash_escape(f.path) + "\" \"" + bash_escape(new_path) + "\"")
			f.path = new_path
			db.save()

	void info(string path)
		LocalFile* f = db.find_by_path(path)
		if !f
			print("ERROR: not in db")
			return
		f.show()
		f.show_info("      ")

	void list(string dir)
		set_working_dir(dir)
		conf.show_pure_local = true
		DBVisitor* vis = new DBLister(self)
		vis.recurse(dir)
		delete vis

	/*void show_status()
		if conf.verbose
			conf.show_pure_local = true
		DBVisitor* vis = new DBStatusReporter(self)
		vis.recurse_all()
		delete vis*/
	
	void tag_add(string path, string key, string value)
		LocalFile* f = db.find_by_path(path)
		if !f
			print("ERROR: not in db")
			return
		f.tag_add(key, value)
		db.dirty = true
	void tag_set(string path, string key, string value)
		LocalFile* f = db.find_by_path(path)
		if !f
			print("ERROR: not in db")
			return
		f.tag_set(key, value)
		db.dirty = true
	void tag_rm(string path, string key, string value)
		LocalFile* f = db.find_by_path(path)
		if !f
			print("ERROR: not in db")
			return
		f.tag_rm(key, value)
		db.dirty = true
	
LocalFileDB db
