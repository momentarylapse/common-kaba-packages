use "config.kaba"



class Tag
	string key
	string value
	string str()
		return key + "=" + value.hex(false)

string tags2str(Tag[] tags)
	string r
	for t,i in tags
		if i > 0
			r += ","
		r += t.str()
	return r

Tag str2tag(string s)
	string[] a = s.explode("=")
	Tag t
	t.key = a[0]
	t.value = a[1]
	return t

Tag strh2tag(string s)
	string[] a = s.explode("=")
	Tag t
	t.key = a[0]
	t.value = a[1].unhex()
	return t


Tag[] strh2tags(string s)
	Tag[] tags
	string[] a = s.explode(",")
	for b in a
		tags.add(strh2tag(b))
	return tags


Tag[] str2tags(string s)
	Tag[] tags
	string[] a = s.explode(",")
	for b in a
		tags.add(str2tag(b))
	return tags

class LocalFile
	// remote
	string id
	int remote_mtime
	// local
	string path
	string hash // can be "" if not local
	int mtime
	int size
	string[] options
	Tag[] tags
	bool is(string option)
		for o in options
			if o == option
				return true
		return false
	void set(string option)
		if is(option)
			return
		options.add(option)
	void unset(string option)
		for o,i in options
			if o == option
				options.remove(i)
				return
	bool mergeable(LocalFile* f)
		if size != f.size
			return false
		if id != f.size
			if id.num > 0 and f.id.num > 0
				return false
		return true
	void merge(LocalFile* f)
		for o in f.options
			set(o)
	void show()
		//if is("nonlocal")
		//	print("NON-NONLOCAL " + path)
		if id.num > 0
			if mtime == remote_mtime
				if conf.verbose
					print("=   " + path)
			else
				print("~   " + path)
		else
			// only local
			if conf.show_pure_local
				print("L+  " + path)
	string str()
		string s
		s += "path: " + path
		s += "\nid: " + id
		s += "\nhash: " + hash
		s += "\nmtime: " + mtime
		if remote_mtime != 0 and remote_mtime != mtime
			s += "\nmtime: " + mtime + " (REMOTE)"
		s += "\nsize: " + size
		s += "\noptions: " + options
		for t in tags
			s += "\n" + t.key + " = " + t.value
		return s

class DBVisitor
	LocalFileDB* db
	string[] ignore
	void __init__(LocalFileDB *_db)
		db = _db
				
	bool is_ignored(string path)
		for i in ignore
			if path.match(i)
				return true
		return false
	
	void add_ignored(string[] ig)
		for i in ig
			ignore.add(i)
	
	void recurse(string dir)
		DirEntry[] list = DirSearch(dir, "*", true)
		for e in list
			if e.is_dir
				if e.name.head(1) != "."
					recurse(dir + "/" + e.name)
			else
				if !is_ignored(dir + "/" + e.name)
					visit(dir + "/" + e.name)
	virtual void visit(string path)

class DBUpdater extends DBVisitor
	override void __init__(LocalFileDB* _db)
		super.__init__(_db)
	override void visit(string path)
		//print("update " + path)
		LocalFile *f = db.find_by_path(path)
		if f
			if f.is("nonlocal")
				f.unset("nonlocal")
				print("NON-NONLOCAL " + path)
			File* ff = FileOpen(path)
			int mtime = ff.getMDate().time
			if mtime == f.mtime
				if f.id == "" and conf.show_pure_local
					print("ADD  " + path)
				// ok
				if conf.verbose
					print("=  " + path)
			else
				// changed?
				string hash = FileHash(path, "md5")
				if hash == f.hash
					// ok
					f.mtime = mtime
					if conf.verbose
						print("=  " + path)
				else
					print("~  " + path)
					f.hash = hash
					f.mtime = mtime
					f.size = ff.getSize()
					if conf.verbose
						print("     hash: " + f.hash)
						print("     time: " + f.mtime)
						print("     size: " + f.size)
			delete ff
		else
			string hash = FileHash(path, "md5")
			f = db.find_by_hash(hash)
			if f
				//print(" FOUND BY HASH " + f.path)
				// moved
				print("MOVE  " + f.path + " > " + path)
				f.path = path
			else
				// new
				print("ADD  " + path)
				LocalFile l
				l.path = path
				l.hash = hash
				l.id = -1
				File* ff = FileOpen(path)
				l.mtime = ff.getMDate().time
				l.size = ff.getSize()
				delete ff
				if conf.verbose
					print("     hash: " + l.hash)
					print("     time: " + l.mtime)
					print("     size: " + l.size)
				db.files.add(l)

class DBStatusReporter extends DBVisitor
	override void __init__(LocalFileDB* _db)
		super.__init__(_db)
	override void visit(string path)
		print(path)
		
class DBDropper extends DBVisitor
	override void __init__(LocalFileDB* _db)
		super.__init__(_db)
	override void visit(string path)
		LocalFile *f = db.find_by_path(path)
		if f
			db.drop(*f)

class LocalFileDB
	LocalFile[] files
	bool dirty
	
	void load()
		files.clear()
		dirty = false
		File *f = FileOpen("db")
		if !f
			return
		int n
		f >> n
		for i in 0:n
			LocalFile ff
			string temp
			f >> ff.id
			f >> ff.path
			f >> ff.hash
			f >> ff.mtime
			f >> ff.remote_mtime
			f >> ff.size
			f >> temp
			ff.options = temp.explode(",")
			f >> temp
			ff.tags = strh2tags(temp)
			ff.unset("")
			if ff.hash == "d41d8cd98f00b204e9800998ecf8427e"
				ff.hash = ""
			if ff.id == "-1"
				ff.id = ""
				
			if ff.hash == ""
				if FileExists(ff.path)
					print("EMPTY HASH: " + ff.path)
					ff.hash = FileHash(ff.path, "md5")
					dirty = true
				else if ff.id == ""
					print("GHOST: " + ff.path)
					dirty = true
					continue
				//else
					// hash='', id='', no file
					//print("EMPTY HASH (REMOTE): " + ff.path)
			if ff.path.num > 0
				LocalFile *l = find_by_hash(ff.hash)
				if l
					if ff.path == l.path
						print("DUPLICATE: " + ff.path)
						if l.mergeable(&ff)
							l.merge(&ff)
							dirty = true
							continue
						else
							print(ff.str())
							print("   <->")
							print(l.str())
							print("###################################")
					else
						print("HASH COLLISION: " + ff.path + "  <->  " + l.path)
				files.add(ff)
		delete(f)
		if dirty
			save()

	void save()
		File *f = FileCreate("db")
		f << files.num
		for ff in files
			f << ff.id
			f << ff.path
			f << ff.hash
			f << ff.mtime
			f << ff.remote_mtime
			f << ff.size
			f << ff.options.join(",")
			f << tags2str(ff.tags)
		delete(f)
		dirty = false

	LocalFile *find_by_id(string id)
		for f in files
			if id == f.id
				return &f
		return nil

	LocalFile *find_by_path(string path)
		for f in files
			if path == f.path
				return &f
		return nil

	LocalFile *find_by_hash(string hash)
		if hash == ""
			return nil
		for f in files
			if hash == f.hash
				return &f
		return nil
		
	LocalFile*[] find_by_tags(string str)
		Tag[] tags = str2tags(str)
		LocalFile*[] list
		for f in files
			bool ok = true
			for t in tags
				bool found = false
				for tt in f.tags
					if tt.key == t.key and tt.value == t.value
						found = true
						break
				if !found
					ok = false
					break
			if ok
				list.add(&f)
		return list
	
	void drop(LocalFile f)
		for ff,i in files
			if ff.path == f.path and ff.hash == f.hash
				print("DROP " + f.path)
				files.remove(i)
				dirty = true
				return

	LocalFile[] get_in_dir(string dir, bool recursive)
		string dir2 = dir
		if dir2.tail(1) != "/"
			dir2 += "/"
			
		LocalFile[] list
		if recursive
			for f in files
				if f.path.head(dir2.num) == dir2
					list.add(f)
		else
			for f in files
				if f.path.dirname() == dir2
					list.add(f)
		return list

	// check for local changes
	void update_local(ConfigDir e)
		print("update local " + e.dir)
		
		DBUpdater* up = new DBUpdater(self)
		up.add_ignored(e.ignore)
		up.recurse(e.dir)
		delete up
		
		LocalFile[] dbfiles = get_in_dir(e.dir, true)
		LocalFile[] todrop
		for ff in dbfiles
			if ff.is("nonlocal")
				print("+R " + ff.path)
				continue
					
			if FileExists(ff.path)
				nil
				// already checked...
			else
				print("-  " + ff.path)
				ff.set("deleted")
				
				if conf.drop_deleted
					todrop.add(ff)
		
		for ff in todrop
			drop(ff)
			
		save()

	// check for local changes
	void add_recursive(string path, bool is_dir)
		
		DBUpdater* up = new DBUpdater(self)
		for e in conf.dirs
			up.add_ignored(e.ignore)
		if is_dir
			up.recurse(path)
		else
			up.visit(path)
		delete up
		
		/*LocalFile[] dbfiles = get_in_dir(e.dir, true)
		LocalFile[] todrop
		for ff in dbfiles
			if ff.is("nonlocal")
				print("+R " + ff.path)
				continue
					
			if FileExists(ff.path)
				nil
				// already checked...
			else
				print("-  " + ff.path)
				ff.set("deleted")
				
				if conf.drop_deleted
					todrop.add(ff)
		
		for ff in todrop
			drop(ff)*/
			
		save()

	void rm_recursive(string path, bool is_dir)
		
		DBVisitor* vis = new DBDropper(self)
		for e in conf.dirs
			vis.add_ignored(e.ignore)
		if is_dir
			vis.recurse(path)
		else
			vis.visit(path)
		delete vis
			
		save()
	
	void rehash()
		for f in files
			//LocalFile* f = find_by_path("/home/michi/Dokumente/Wichtige Dokumente/Bank/Kontoauszug 649433009 - 2015-01.pdf")
			print(f.path)
			string h2 = FileHash(f.path, "md5")
			if h2.num == 0
				continue
			if h2 != f.hash
				print(h2 + " != " + f.hash)
				f.hash = h2
				save()

	void show_status()
		conf.show_pure_local = true
		for f in files
			f.show()
		/*DBVisitor* vis = new DBStatusReporter(self)
		for e in conf.dirs
			vis.add_ignored(e.ignore)
			vis.recurse(e.dir)
		delete vis*/
	
LocalFileDB db
