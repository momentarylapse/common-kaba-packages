use common
use parser

string add(string a, string b)
	#return i2s(s2i(a) + s2i(b))
	vli va = a, vb = b
	return str(va + vb)

string sub(string a, string b)
	#return i2s(s2i(a) - s2i(b))
	vli va = a, vb = b
	return str(va - vb)

string mul(string a, string b)
	#return i2s(s2i(a) * s2i(b))
	vli va = a, vb = b
	return str(va * vb)

#string mod(string a, string b)
#	#return i2s(s2i(a) * s2i(b))
#	vli va = a, vb = b, rem
#	va.div(b, rem)
#	return rem.str()

string exponent(string a, string b)
	vli va = a, vb = b
	return str(va.pow(vb))

string gcd(string a, string b)
	vli va = a, vb = b
	return str(va.gcd(vb))

void append_terms(Term*[] a, Term*[] b)
	for x in b
		a.add(x)

void append_neg(bool[] a, bool[] b)
	for x in b
		a.add(x)

void print_group(Term*[] gr)
	print("[" + [for x in gr str(*x)].join(", ") + "]")

Term*[] GetEqualOps(Term* t)
	Term*[] l
	if t.type == TYPE_OPERATOR
		Term* p1 = t.params[0]
		Term* p2 = t.params[1]
		if p1.name == t.name
			l = GetEqualOps(p1)
		else
			l.add(p1)
		if p2.name == t.name
			append_terms(l, GetEqualOps(p2))
		else
			l.add(p2)
	return l

Term*[] extract_add_group(Term* t, bool[] negative)
	Term*[] l
	if t.name == "+"
		bool[] n0, n1
		append_terms(l, extract_add_group(t.params[0], n0))
		append_terms(l, extract_add_group(t.params[1], n1))
		append_neg(negative, n0)
		append_neg(negative, n1)
	else if t.name == "-"
		bool[] n0, n1
		append_terms(l, extract_add_group(t.params[0], n0))
		append_terms(l, extract_add_group(t.params[1], n1))
		append_neg(negative, n0)
		for n in n1
			negative.add(!n)
	else
		negative.add(false)
		l.add(t)
	return l

# [2x, 3y, z] -> [2,3,1], [x,y,z]
string[] split_off_factor(Term*[] l)
	string[] factor
	for x,i in l
		string f = "1"
		if x.name == "*"
			if x.params[0].type == TYPE_NUMBER
				f = x.params[0].name
				l[i] = x.params[1]
		factor.add(f)
	return factor

# a/b kürzen
Term *SimplifyNumberDivision(Term *t, string a, string b)
	vli va = a
	vli vb = b
	vli tt = va, rem
	tt.div(vb, rem)
	vli vli0 = 0
	if rem == vli0
		return AddNumber(tt.str())
	string g = gcd(a, b)
	if g != "1"
		vli vg = g
		va.idiv(vg, tt)
		vb.idiv(vg, tt)
		if vb.sign
			vb.sign = false
			va.sign = !va.sign
		return AddOperator(t.name, AddNumber(va.str()), AddNumber(vb.str()))
	return t

Term *SimplifyNumericals(Term *t)
	if !t
		return nil
	# rekursiv
	bool need_new = false
	Term*[8] p
	for i in 0:t.params.num
		p[i] = SimplifyNumericals(t.params[i])
		if p[i] != t.params[i]
			need_new = true
	if need_new
		t = t.copy()
		for i in 0:t.params.num
			t.params[i] = p[i]
		
	# selbst
	if t.type == TYPE_OPERATOR
		Term *p1 = t.params[0]
		Term *p2 = t.params[1]
		if (p1.type == TYPE_NUMBER) and (p2.type == TYPE_NUMBER)
			string a = p1.name
			string b = p2.name
			#if t.name == "+"
#				return AddNumber(add(a, b))
			if t.name == "-"
				return AddNumber(sub(a, b))
			#if t.name == "*"
#				return AddNumber(mul(a, b))
			if t.name == "/"
				return SimplifyNumberDivision(t, a, b)
			if t.name == "^"
				return AddNumber(exponent(a, b))
	return t

bool literally_equal(Term *a, Term *b)
	if a.name != b.name
		return false
	for i in 0:a.params.num
		if !literally_equal(a.params[i], b.params[i])
			return false
	return true
	

# return: counting multiplicities
int[] make_unique(Term*[] l)
	int[] multiplicity
	
	for i in 0:len(l)
		multiplicity.add(1)
	for i in 0:len(l)
		for j in i+1:len(l)
			if literally_equal(l[i], l[j])
				multiplicity[i] += multiplicity[j]
				multiplicity[j] = 0
	for i in 0:len(l)
		if multiplicity[i] == 0
			multiplicity.remove(i)
			l.remove(i)
			i --
	return multiplicity

				
	
void sort_group(Term*[] l)
	# alle Terme "rendern"...   besser eine comp(term, term)-Funktion
	string[] s
	for i in 0:l.num
		string ss = str(*l[i])
		s.add(ss)
	
	# sortieren
	for i in 0:l.num-1
		for j in i+1:l.num
			if s[i].compare(s[j]) > 0
				l.swap(i, j)
				s.swap(i, j)



void make_unique_in_product(Term*[] l)
	Term*[] exponents
	
	for x,i in l
		Term* e = nil
		if x.name == "^"
			e = x.params[1]
			l[i] = x.params[0]
		if !e
			e = AddNumber("1")
		exponents.add(e)
	for i in 0:len(l)
		for j in i+1:len(l)
			if literally_equal(l[i], l[j])
				exponents[i] = AddOperator("+", exponents[i], exponents[j])
				exponents.remove(j)
				l.remove(j)
				j --
	for x,i in l
		if exponents[i].name != "1"
			l[i] = AddOperator("^", x, normalize(exponents[i]))


# Zahlfaktoren zusammenfassen
# TODO: gleiche Faktoren mit unterschiedlichen Potenzen... Potenzen addieren
# TODO: Brüche... kürzen...
Term* normalize_product(Term* t)
	if t.type != TYPE_OPERATOR
		return t

	let l = GetEqualOps(t)
	
	
	string num = "1"
	for i in 0:l.num
		if l[i].type == TYPE_NUMBER
			num = mul(num, l[i].name)
			l.remove(i)
			i --
	
	if num == "0"
		return AddNumber("0")
	if l.num == 0
		return AddNumber(num)
	
	#print_group(l)
	make_unique_in_product(l)
	#print_group(l)
	sort_group(l)
	
	let r = l[0]
	for i in 1:l.num
		r = AddOperator("*", r, l[i])
	if num != "1"
		r = AddOperator("*", AddNumber(num), r)
	return r



void make_unique_in_sum(Term*[] l, bool[] negative)
	string[] multiplicity
	#print_group(l)
	
	for x,i in l
		string m = "1"
		if x.name == "*"
			if x.params[0].type == TYPE_NUMBER
				m = x.params[0].name
				l[i] = x.params[1]
		if negative[i]
			m = mul(m, "-1")
		multiplicity.add(m)
	for i in 0:len(l)
		for j in i+1:len(l)
			if literally_equal(l[i], l[j])
				multiplicity[i] = add(multiplicity[i], multiplicity[j])
				multiplicity.remove(j)
				l.remove(j)
				j --
	for x,i in l
		if multiplicity[i] == "0"
			l.remove(i)
			negative.remove(i)
			multiplicity.remove(i)
			i --
	for x,i in l
		if multiplicity[i] != "1"
			l[i] = AddOperator("*", AddNumber(multiplicity[i]), x)


Term* normalize_sum(Term* t)
	bool[] negative
	let l = extract_add_group(t, negative)
	#print_group(l)
	
	# add constants
	string num = "0"
	for i in 0:l.num
		if l[i].type == TYPE_NUMBER
			if negative[i]
				num = sub(num, l[i].name)
			else
				num = add(num, l[i].name)
			l.remove(i)
			negative.remove(i)
			i --
	
	

	#print_group(l)
	make_unique_in_sum(l, negative)
	#print_group(l)
	
	# all constant numbers
	if l.num == 0
		return AddNumber(num)
	
	sort_group(l)
	
	let t_r = l[0]
	for i in 1:l.num
		t_r = AddOperator("+", t_r, l[i])
	if num != "0"
		return AddOperator("+", t_r, AddNumber(num))
	return t_r

Term* normalize_exponent(Term* t)
	let p0 = t.params[0]
	let p1 = t.params[1]
	if p1.type == TYPE_NUMBER
		if p1.name == "1"
			return p0
		if p1.name == "0"
			return AddNumber("1")
		if p0.type == TYPE_NUMBER
			return AddNumber(exponent(p0.name, p1.name))
	return t

Term* normalize_function(Term* t)
	if t.name == "ln"
		let p = t.params[0]
		if p.name == "^"
			return normalize(AddOperator("*", p.params[1], AddFunction("ln", [p.params[0]])))
		if p.name == "e"
			return AddNumber("1")
	if t.name == "sin"
		let p = t.params[0]
		if p.name in ["0", "pi"]
			return AddNumber("0")
	if t.name == "cos"
		let p = t.params[0]
		if p.name == "0"
			return AddNumber("1")
		if p.name == "pi"
			return AddNumber("-1")
	#if t.name == "sqrt"
		#if p.type == TYPE_NUMBER
			# test... apply
			#return AddNumber("...")
	return t


Term* normalize(Term* t)
	if !t
		return nil

	# recursion
	for i in 0:t.params.num
		t.params[i] = normalize(t.params[i])
		
	# self
	if t.type == TYPE_FUNCTION
		return normalize_function(t)
	if t.name == "*"
		return normalize_product(t)
	if t.name in ["+", "-"]
		return normalize_sum(t)
	if t.name == "^"
		return normalize_exponent(t)
	return t
