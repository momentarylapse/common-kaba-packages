use "common.kaba"
use "parser.kaba"

string add(string a, string b)
	#return i2s(s2i(a) + s2i(b))
	vli va = a, vb = b
	return (va + vb).str()

string sub(string a, string b)
	#return i2s(s2i(a) - s2i(b))
	vli va = a, vb = b
	return (va - vb).str()

string mul(string a, string b)
	#return i2s(s2i(a) * s2i(b))
	vli va = a, vb = b
	return (va * vb).str()

#string mod(string a, string b)
#	#return i2s(s2i(a) * s2i(b))
#	vli va = a, vb = b, rem
#	va.div(b, rem)
#	return rem.str()

string exponent(string a, string b)
	vli va = a, vb = b
	return va.pow(vb).str()

string gcd(string a, string b)
	vli va = a, vb = b
	return va.gcd(vb).str()

void GetEqualOps(Term* t, Term*[] l)
	if t.type == TYPE_OPERATOR
		Term* p1 = t.params[0]
		Term* p2 = t.params[1]
		Term*[] l2
		if p1.name == t.name
			GetEqualOps(p1, l2)
		else
			l.add(p1)
		if p2.name == t.name
			GetEqualOps(p2, l2)
		else
			l.add(p2)
		for i in 0:l2.num
			l.add(l2[i])

# a/b k체rzen
Term *SimplifyNumberDivision(Term *t, string a, string b)
	vli va = a
	vli vb = b
	vli tt = va, rem
	tt.div(vb, rem)
	vli vli0 = 0
	if rem == vli0
		return AddNumber(tt.str())
	string g = gcd(a, b)
	if g != "1"
		vli vg = g
		va.idiv(vg, tt)
		vb.idiv(vg, tt)
		if vb.sign
			vb.sign = false
			va.sign = !va.sign
		return AddOperator(t.name, AddNumber(va.str()), AddNumber(vb.str()))
	return t

Term *SimplifyNumericals(Term *t)
	if !t
		return nil
	# rekursiv
	bool need_new = false
	Term*[8] p
	for i in 0:t.params.num
		p[i] = SimplifyNumericals(t.params[i])
		if p[i] != t.params[i]
			need_new = true
	if need_new
		t = t.copy()
		for i in 0:t.params.num
			t.params[i] = p[i]
		
	# selbst
	if t.type == TYPE_OPERATOR
		Term *p1 = t.params[0]
		Term *p2 = t.params[1]
		if (p1.type == TYPE_NUMBER) and (p2.type == TYPE_NUMBER)
			string a = p1.name
			string b = p2.name
			#if t.name == "+"
#				return AddNumber(add(a, b))
			if t.name == "-"
				return AddNumber(sub(a, b))
			#if t.name == "*"
#				return AddNumber(mul(a, b))
			if t.name == "/"
				return SimplifyNumberDivision(t, a, b)
			if t.name == "^"
				return AddNumber(exponent(a, b))
	return t

bool LiterallyEqual(Term *a, Term *b)
	if a.name != b.name
		return false
	for i in 0:a.params.num
		if !LiterallyEqual(a.params[i], b.params[i])
			return false
	return true

void SortExprList(Term*[] l, int[] n, bool find_duplicate)
	# alle Terme "rendern"...   besser eine comp(term, term)-Funktion
	string[] s
	for i in 0:l.num
		string ss = ExprToStr(l[i])
		s.add(ss)
	
	# sortieren
	for i in 0:l.num-1
		for j in i+1:l.num
			if s[i].compare(s[j]) > 0
				l.swap(i, j)
				s.swap(i, j)
	if find_duplicate
		for i in 0:l.num
			int num = 1
			for j in i+1:l.num
				if s[i] == s[j]
					l.remove(j)
					s[j].clear()
					s.remove(j)
					j --
					num ++
				else
					break
			n.add(num)
	
	# aufr채umen
	for i in 0:s.num
		s[i].clear()

Term *Multiple(Term *t, int n)
	if n == 1
		return t
	if n == 0
		return AddNumber("0")
	return AddOperator("*", AddNumber(n.str()), t)

Term *Potence(Term *t, int n)
	if n == 1
		return t
	if n == 0
		return AddNumber("1")
	return AddOperator("^", t, AddNumber(n.str()))

# Zahlfaktoren zusammenfassen
# TODO: gleiche Faktoren mit unterschiedlichen Potenzen... Potenzen addieren
# TODO: Br체che... k체rzen...
Term* NormalizeProduct(Term* t)
	if t.type != TYPE_OPERATOR
		return t
	Term*[] l
	GetEqualOps(t, l)
	string num = "1"
	for i in 0:l.num
		if l[i].type == TYPE_NUMBER
			num = mul(num, l[i].name)
			l.remove(i)
			i --
	
	if num == "0"
		return AddNumber("0")
	if l.num == 0
		return AddNumber(num)
	
	int[] neq
	SortExprList(l, neq, true)
	
	Term* t_r = Potence(l[0], neq[0])
	for i in 1:l.num
		Term* t_mul = t.copy()
		t_mul.params[0] = t_r
		t_mul.params[1] = Potence(l[i], neq[i])
		t_r = t_mul
	if num != "1"
		Term* t_mul = t.copy()
		t_mul.params[0] = AddNumber(num)
		t_mul.params[1] = t_r
		t_r = t_mul
	return t_r

# Zahlterme zusammenfassen
# TODO: gleiche Summanden...
Term *NormalizeSum(Term *t)
	Term*[] l
	GetEqualOps(t, l)
	string num = "0"
	for i in 0:l.num
		if l[i].type == TYPE_NUMBER
			num = add(num, l[i].name)
			l.remove(i)
			i --
	
	if l.num == 0
		return AddNumber(num)

	int[] neq
	SortExprList(l, neq, true)
	
	Term* t_r = Multiple(l[0], neq[0])
	for i in 1:l.num
		Term *t_sum = t.copy()
		t_sum.params[0] = t_r
		t_sum.params[1] = Multiple(l[i], neq[i])
		t_r = t_sum
	t_r = NormalizeProduct(t_r)
	if num != "0"
		return AddOperator("+", t_r, AddNumber(num))
	return t_r

Term *NormalizeExponent(Term *t)
	Term *p1 = t.params[1]
	if p1.type == TYPE_NUMBER
		if p1.name == "1"
			return t.params[0]
		if p1.name == "0"
			return AddNumber("1")
	return t.copy()

Term *NormalizeRec(Term *t, bool do_normalize)
	if !t
		return nil
	# rekursiv
	bool need_new = false
	Term*[8] p
	for i in 0:t.params.num
		bool dnr = true
		if t.name == "*"
			if t.params[i].name == "*"
				dnr = false
		if t.name == "+"
			if t.params[i].name == "+"
				dnr = false
		p[i] = NormalizeRec(t.params[i], dnr)
		if p[i] != t.params[i]
			need_new = true
	if need_new
		t = t.copy()
		for i in 0:t.params.num
			t.params[i] = p[i]
		
	# selbst
	if do_normalize
		if t.name == "*"
			return NormalizeProduct(t)
		if t.name == "+"
			return NormalizeSum(t)
		if t.name == "^"
			return NormalizeExponent(t)
	return t

Term *Normalize(Term *t)
	return NormalizeRec(t, true)
	